// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// This file is generated by Apache Fory compiler.

package auto_id

import (
	"fmt"
	fory "github.com/apache/fory/go/fory"
	threadsafe "github.com/apache/fory/go/fory/threadsafe"
	"reflect"
	"sync"
)

type Status int32

const (
	StatusUnknown Status = 0
	StatusOk      Status = 1
)

type WrapperCase uint32

const (
	WrapperCaseInvalid  WrapperCase = WrapperCase(0)
	WrapperCaseEnvelope WrapperCase = 1
	WrapperCaseRaw      WrapperCase = 2
)

// Type ID 1471345060 is generated from auto_id.Wrapper
type Wrapper struct {
	case_ WrapperCase
	value any
}

func EnvelopeWrapper(v *Envelope) Wrapper {
	if v == nil {
		panic("EnvelopeWrapper: nil pointer")
	}
	return Wrapper{case_: WrapperCaseEnvelope, value: v}
}

func RawWrapper(v string) Wrapper {
	return Wrapper{case_: WrapperCaseRaw, value: v}
}

func (u Wrapper) Case() WrapperCase { return u.case_ }
func (u Wrapper) IsSet() bool       { return u.case_ != WrapperCaseInvalid && u.value != nil }

func (u Wrapper) AsEnvelope() (*Envelope, bool) {
	if u.case_ != WrapperCaseEnvelope {
		var zero *Envelope
		return zero, false
	}
	v, ok := u.value.(*Envelope)
	if !ok {
		var zero *Envelope
		return zero, false
	}
	return v, true
}

func (u Wrapper) AsRaw() (string, bool) {
	if u.case_ != WrapperCaseRaw {
		var zero string
		return zero, false
	}
	v, ok := u.value.(string)
	if !ok {
		var zero string
		return zero, false
	}
	return v, true
}

func (u Wrapper) Visit(visitor WrapperVisitor) error {
	if u.case_ == WrapperCaseInvalid || u.value == nil {
		if visitor.Invalid != nil {
			return visitor.Invalid()
		}
		return nil
	}
	switch u.case_ {
	case WrapperCaseEnvelope:
		v, ok := u.value.(*Envelope)
		if !ok {
			return fmt.Errorf("corrupted Wrapper: case=Envelope but invalid value")
		}
		if v == nil {
			return fmt.Errorf("corrupted Wrapper: case=Envelope but nil value")
		}
		if visitor.Envelope != nil {
			return visitor.Envelope(v)
		}
		return nil
	case WrapperCaseRaw:
		v, ok := u.value.(string)
		if !ok {
			return fmt.Errorf("corrupted Wrapper: case=Raw but invalid value")
		}
		if visitor.Raw != nil {
			return visitor.Raw(v)
		}
		return nil
	default:
		return fmt.Errorf("unknown Wrapper case: %d", u.case_)
	}
}

type WrapperVisitor struct {
	Invalid  func() error
	Envelope func(*Envelope) error
	Raw      func(string) error
}

func (u Wrapper) ForyUnionMarker() {}

func (u Wrapper) ForyUnionGet() (uint32, any) { return uint32(u.case_), u.value }
func (u *Wrapper) ForyUnionSet(caseId uint32, value any) {
	u.case_ = WrapperCase(caseId)
	u.value = value
}

func (u *Wrapper) ToBytes() ([]byte, error) {
	return getFory().Serialize(u)
}

func (u *Wrapper) FromBytes(data []byte) error {
	return getFory().Deserialize(data, u)
}

type Envelope_DetailCase uint32

const (
	Envelope_DetailCaseInvalid Envelope_DetailCase = Envelope_DetailCase(0)
	Envelope_DetailCasePayload Envelope_DetailCase = 1
	Envelope_DetailCaseNote    Envelope_DetailCase = 2
)

// Type ID 1609214087 is generated from auto_id.Envelope.Detail
type Envelope_Detail struct {
	case_ Envelope_DetailCase
	value any
}

func PayloadEnvelope_Detail(v *Envelope_Payload) Envelope_Detail {
	if v == nil {
		panic("PayloadEnvelope_Detail: nil pointer")
	}
	return Envelope_Detail{case_: Envelope_DetailCasePayload, value: v}
}

func NoteEnvelope_Detail(v string) Envelope_Detail {
	return Envelope_Detail{case_: Envelope_DetailCaseNote, value: v}
}

func (u Envelope_Detail) Case() Envelope_DetailCase { return u.case_ }
func (u Envelope_Detail) IsSet() bool               { return u.case_ != Envelope_DetailCaseInvalid && u.value != nil }

func (u Envelope_Detail) AsPayload() (*Envelope_Payload, bool) {
	if u.case_ != Envelope_DetailCasePayload {
		var zero *Envelope_Payload
		return zero, false
	}
	v, ok := u.value.(*Envelope_Payload)
	if !ok {
		var zero *Envelope_Payload
		return zero, false
	}
	return v, true
}

func (u Envelope_Detail) AsNote() (string, bool) {
	if u.case_ != Envelope_DetailCaseNote {
		var zero string
		return zero, false
	}
	v, ok := u.value.(string)
	if !ok {
		var zero string
		return zero, false
	}
	return v, true
}

func (u Envelope_Detail) Visit(visitor Envelope_DetailVisitor) error {
	if u.case_ == Envelope_DetailCaseInvalid || u.value == nil {
		if visitor.Invalid != nil {
			return visitor.Invalid()
		}
		return nil
	}
	switch u.case_ {
	case Envelope_DetailCasePayload:
		v, ok := u.value.(*Envelope_Payload)
		if !ok {
			return fmt.Errorf("corrupted Envelope_Detail: case=Payload but invalid value")
		}
		if v == nil {
			return fmt.Errorf("corrupted Envelope_Detail: case=Payload but nil value")
		}
		if visitor.Payload != nil {
			return visitor.Payload(v)
		}
		return nil
	case Envelope_DetailCaseNote:
		v, ok := u.value.(string)
		if !ok {
			return fmt.Errorf("corrupted Envelope_Detail: case=Note but invalid value")
		}
		if visitor.Note != nil {
			return visitor.Note(v)
		}
		return nil
	default:
		return fmt.Errorf("unknown Envelope_Detail case: %d", u.case_)
	}
}

type Envelope_DetailVisitor struct {
	Invalid func() error
	Payload func(*Envelope_Payload) error
	Note    func(string) error
}

func (u Envelope_Detail) ForyUnionMarker() {}

func (u Envelope_Detail) ForyUnionGet() (uint32, any) { return uint32(u.case_), u.value }
func (u *Envelope_Detail) ForyUnionSet(caseId uint32, value any) {
	u.case_ = Envelope_DetailCase(caseId)
	u.value = value
}

func (u *Envelope_Detail) ToBytes() ([]byte, error) {
	return getFory().Serialize(u)
}

func (u *Envelope_Detail) FromBytes(data []byte) error {
	return getFory().Deserialize(data, u)
}

// Type ID 2862577837 is generated from auto_id.Envelope.Payload
type Envelope_Payload struct {
	Value int32 `fory:"id=1,compress=true"`
}

func (m *Envelope_Payload) ToBytes() ([]byte, error) {
	return getFory().Serialize(m)
}

func (m *Envelope_Payload) FromBytes(data []byte) error {
	return getFory().Deserialize(data, m)
}

// Type ID 3022445236 is generated from auto_id.Envelope
type Envelope struct {
	Id      string            `fory:"id=1"`
	Payload *Envelope_Payload `fory:"id=2,nullable"`
	Detail  Envelope_Detail   `fory:"id=3"`
	Status  Status            `fory:"id=4"`
}

func (m *Envelope) ToBytes() ([]byte, error) {
	return getFory().Serialize(m)
}

func (m *Envelope) FromBytes(data []byte) error {
	return getFory().Deserialize(data, m)
}

func RegisterTypes(f *fory.Fory) error {
	if err := f.RegisterNamedEnum(Status(0), "1124725126"); err != nil {
		return err
	}
	if err := f.RegisterNamedUnion(Wrapper{}, "1471345060", fory.NewUnionSerializer(fory.UnionCase{ID: 1, Type: reflect.TypeOf((*Envelope)(nil)), TypeID: fory.NAMED_STRUCT}, fory.UnionCase{ID: 2, Type: reflect.TypeOf((*string)(nil)).Elem(), TypeID: fory.STRING})); err != nil {
		return err
	}
	if err := f.RegisterNamedUnion(Envelope_Detail{}, "1609214087", fory.NewUnionSerializer(fory.UnionCase{ID: 1, Type: reflect.TypeOf((*Envelope_Payload)(nil)), TypeID: fory.NAMED_STRUCT}, fory.UnionCase{ID: 2, Type: reflect.TypeOf((*string)(nil)).Elem(), TypeID: fory.STRING})); err != nil {
		return err
	}
	if err := f.RegisterNamedStruct(Envelope_Payload{}, "2862577837"); err != nil {
		return err
	}
	if err := f.RegisterNamedStruct(Envelope{}, "3022445236"); err != nil {
		return err
	}
	return nil
}

func createFory() *fory.Fory {
	f := fory.New(fory.WithXlang(true), fory.WithRefTracking(true), fory.WithCompatible(true))
	if err := RegisterTypes(f); err != nil {
		panic(err)
	}
	return f
}

var (
	foryOnce     sync.Once
	foryInstance *threadsafe.Fory
)

func getFory() *threadsafe.Fory {
	foryOnce.Do(func() {
		foryInstance = threadsafe.NewWithFactory(createFory)
	})
	return foryInstance
}
