# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
# This file is generated by Apache Fory compiler.

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum, IntEnum
from pyfory.union import Union, UnionSerializer
from typing import Dict, List, Optional, cast
import pyfory
import threading


class Status(IntEnum):
    UNKNOWN = 0
    OK = 1


class WrapperCase(Enum):
    ENVELOPE = 1
    RAW = 2

# Type ID 1471345060 is generated from auto_id.Wrapper
class Wrapper(Union):
    __slots__ = ("_case",)

    def __init__(self, case: WrapperCase, value: object) -> None:
        super().__init__(case.value, value)
        self._case = case
        self._validate()

    @classmethod
    def envelope(cls, v: Envelope) -> "Wrapper":
        return cls(WrapperCase.ENVELOPE, v)

    @classmethod
    def raw(cls, v: str) -> "Wrapper":
        return cls(WrapperCase.RAW, v)

    @classmethod
    def _from_case_id(cls, case_id: int, value: object) -> "Wrapper":
        if case_id == WrapperCase.ENVELOPE.value:
            return cls(WrapperCase.ENVELOPE, value)
        if case_id == WrapperCase.RAW.value:
            return cls(WrapperCase.RAW, value)
        raise ValueError("unknown Wrapper case id: {}".format(case_id))

    def _validate(self) -> None:
        if self._case == WrapperCase.ENVELOPE and not isinstance(self._value, Envelope):
            raise TypeError("Wrapper.envelope(...) requires Envelope")
        if self._case == WrapperCase.RAW and not isinstance(self._value, str):
            raise TypeError("Wrapper.raw(...) requires str")

    def case(self) -> WrapperCase:
        return self._case

    def case_id(self) -> int:
        return self._case_id

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Wrapper):
            return NotImplemented
        return self._case == other._case and self._value == other._value

    def is_envelope(self) -> bool:
        return self._case == WrapperCase.ENVELOPE

    def envelope_value(self) -> Envelope:
        if self._case != WrapperCase.ENVELOPE:
            raise ValueError("Wrapper is not envelope")
        return cast(Envelope, self._value)

    def set_envelope(self, v: Envelope) -> None:
        self._case = WrapperCase.ENVELOPE
        self._case_id = WrapperCase.ENVELOPE.value
        self._value = v
        self._validate()

    def is_raw(self) -> bool:
        return self._case == WrapperCase.RAW

    def raw_value(self) -> str:
        if self._case != WrapperCase.RAW:
            raise ValueError("Wrapper is not raw")
        return cast(str, self._value)

    def set_raw(self, v: str) -> None:
        self._case = WrapperCase.RAW
        self._case_id = WrapperCase.RAW.value
        self._value = v
        self._validate()

    def to_bytes(self) -> bytes:
        return _get_fory().serialize(self)

    @classmethod
    def from_bytes(cls, data: bytes) -> "Wrapper":
        return _get_fory().deserialize(data)

    def __bytes__(self) -> bytes:
        return self.to_bytes()

class WrapperSerializer(UnionSerializer):

    def __init__(self, fory: pyfory.Fory):
        super().__init__(fory, Wrapper, {
            1: Envelope,
            2: str,
        })



# Type ID 3022445236 is generated from auto_id.Envelope
@dataclass
class Envelope:
    class DetailCase(Enum):
        PAYLOAD = 1
        NOTE = 2

    # Type ID 1609214087 is generated from auto_id.Envelope.Detail
    class Detail(Union):
        __slots__ = ("_case",)

        def __init__(self, case: Envelope.DetailCase, value: object) -> None:
            super().__init__(case.value, value)
            self._case = case
            self._validate()

        @classmethod
        def payload(cls, v: Envelope.Payload) -> "Envelope.Detail":
            return cls(Envelope.DetailCase.PAYLOAD, v)

        @classmethod
        def note(cls, v: str) -> "Envelope.Detail":
            return cls(Envelope.DetailCase.NOTE, v)

        @classmethod
        def _from_case_id(cls, case_id: int, value: object) -> "Envelope.Detail":
            if case_id == Envelope.DetailCase.PAYLOAD.value:
                return cls(Envelope.DetailCase.PAYLOAD, value)
            if case_id == Envelope.DetailCase.NOTE.value:
                return cls(Envelope.DetailCase.NOTE, value)
            raise ValueError("unknown Detail case id: {}".format(case_id))

        def _validate(self) -> None:
            if self._case == Envelope.DetailCase.PAYLOAD and not isinstance(self._value, Envelope.Payload):
                raise TypeError("Detail.payload(...) requires Envelope.Payload")
            if self._case == Envelope.DetailCase.NOTE and not isinstance(self._value, str):
                raise TypeError("Detail.note(...) requires str")

        def case(self) -> Envelope.DetailCase:
            return self._case

        def case_id(self) -> int:
            return self._case_id

        def __eq__(self, other: object) -> bool:
            if not isinstance(other, Envelope.Detail):
                return NotImplemented
            return self._case == other._case and self._value == other._value

        def is_payload(self) -> bool:
            return self._case == Envelope.DetailCase.PAYLOAD

        def payload_value(self) -> Envelope.Payload:
            if self._case != Envelope.DetailCase.PAYLOAD:
                raise ValueError("Detail is not payload")
            return cast(Envelope.Payload, self._value)

        def set_payload(self, v: Envelope.Payload) -> None:
            self._case = Envelope.DetailCase.PAYLOAD
            self._case_id = Envelope.DetailCase.PAYLOAD.value
            self._value = v
            self._validate()

        def is_note(self) -> bool:
            return self._case == Envelope.DetailCase.NOTE

        def note_value(self) -> str:
            if self._case != Envelope.DetailCase.NOTE:
                raise ValueError("Detail is not note")
            return cast(str, self._value)

        def set_note(self, v: str) -> None:
            self._case = Envelope.DetailCase.NOTE
            self._case_id = Envelope.DetailCase.NOTE.value
            self._value = v
            self._validate()

        def to_bytes(self) -> bytes:
            return _get_fory().serialize(self)

        @classmethod
        def from_bytes(cls, data: bytes) -> "Envelope.Detail":
            return _get_fory().deserialize(data)

        def __bytes__(self) -> bytes:
            return self.to_bytes()

    class DetailSerializer(UnionSerializer):

        def __init__(self, fory: pyfory.Fory):
            super().__init__(fory, Envelope.Detail, {
                1: Envelope.Payload,
                2: str,
            })


    # Type ID 2862577837 is generated from auto_id.Envelope.Payload
    @dataclass
    class Payload:
        value: pyfory.int32 = pyfory.field(id=1, default=0)

        def to_bytes(self) -> bytes:
            return _get_fory().serialize(self)

        @classmethod
        def from_bytes(cls, data: bytes) -> "Payload":
            return _get_fory().deserialize(data)

        def __bytes__(self) -> bytes:
            return self.to_bytes()


    id: str = pyfory.field(id=1, default="")
    payload: Optional[Envelope.Payload] = pyfory.field(id=2, nullable=True, default=None)
    detail: Envelope.Detail = pyfory.field(id=3, default=None)
    status: Status = pyfory.field(id=4, default=None)

    def to_bytes(self) -> bytes:
        return _get_fory().serialize(self)

    @classmethod
    def from_bytes(cls, data: bytes) -> "Envelope":
        return _get_fory().deserialize(data)

    def __bytes__(self) -> bytes:
        return self.to_bytes()



def register_auto_id_types(fory: pyfory.Fory):
    fory.register_type(Status, namespace="", typename="1124725126")
    fory.register_union(Wrapper, namespace="", typename="1471345060", serializer=WrapperSerializer(fory))
    fory.register_type(Envelope, namespace="", typename="3022445236")
    fory.register_union(Envelope.Detail, namespace="", typename="1609214087", serializer=Envelope.DetailSerializer(fory))
    fory.register_type(Envelope.Payload, namespace="", typename="2862577837")

_fory_lock = threading.Lock()
_threadsafe_fory = None

def _create_fory() -> pyfory.Fory:
    fory = pyfory.Fory(xlang=True, ref=True, compatible=True)
    register_auto_id_types(fory)
    return fory

def _get_fory() -> pyfory.ThreadSafeFory:
    global _threadsafe_fory
    if _threadsafe_fory is None:
        with _fory_lock:
            if _threadsafe_fory is None:
                _threadsafe_fory = pyfory.ThreadSafeFory(fory_factory=_create_fory)
    return _threadsafe_fory
