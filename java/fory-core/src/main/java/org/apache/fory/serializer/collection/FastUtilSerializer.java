/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.fory.serializer.collection;

import static org.apache.fory.serializer.CodegenSerializer.supportCodegenForJavaSerialization;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import org.apache.fory.Fory;
import org.apache.fory.builder.CodecUtils;
import org.apache.fory.memory.MemoryBuffer;
import org.apache.fory.serializer.Serializer;
import org.apache.fory.serializer.Serializers;

/**
 * This file is based on code from Apache Giraph https://github.com/apache/giraph. Original
 * file:FastUtilSerializer.java
 */
public class FastUtilSerializer<T> extends Serializer<T> {

  /** List of all types generated by fastutil. */
  private static final String[] PRIMITIVE_TYPES =
      new String[] {"Boolean", "Byte", "Short", "Int", "Long", "Float", "Double", "Char", "Object"};

  /** List of all types used as keys in fastutil. */
  private static final String[] PRIMITIVE_KEY_TYPES =
      new String[] {"Byte", "Short", "Int", "Long", "Float", "Double", "Char", "Object"};

  /** Field serializer for this fastutil class. */
  private final Serializer<T> fieldSerializer;

  /** Handle to writeObject Method on this fastutil class. */
  private final Method writeMethod;

  /** Handle to readObject Method on this fastutil class. */
  private final Method readMethod;

  private final FastutilObjectOutputStream outputWrapper;

  private final FastutilObjectInputStream inputWrapper;

  /**
   * Creates and initializes new serializer for a given fastutil class.
   *
   * @param fory Fory instance
   * @param cls Fastutil class
   */
  public FastUtilSerializer(Fory fory, Class<T> cls) {
    super(fory, cls);

    boolean codegen =
        supportCodegenForJavaSerialization(cls) && fory.getConfig().isCodeGenEnabled();
    boolean metaContextShareEnabled = fory.getConfig().isMetaShareEnabled();

    Class<? extends Serializer> serializerClass =
        codegen && metaContextShareEnabled
            ? CodecUtils.loadOrGenObjectCodecClass(cls, fory)
            : fory.getClassResolver().getObjectSerializerClass(cls, sc -> {});

    this.fieldSerializer = Serializers.newSerializer(fory, cls, serializerClass);

    try {
      writeMethod = cls.getDeclaredMethod("writeObject", ObjectOutputStream.class);
      writeMethod.setAccessible(true);
      readMethod = cls.getDeclaredMethod("readObject", ObjectInputStream.class);
      readMethod.setAccessible(true);
    } catch (NoSuchMethodException e) {
      throw new RuntimeException(
          "Fastutil class " + cls + " doesn't have readObject/writeObject methods", e);
    }
    try {
      outputWrapper = new FastutilObjectOutputStream();
      inputWrapper = new FastutilObjectInputStream();
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  @Override
  public void write(MemoryBuffer buffer, T object) {
    fieldSerializer.write(buffer, object);
    outputWrapper.set(buffer, fory);
    try {
      writeMethod.invoke(object, outputWrapper);
    } catch (IllegalAccessException | InvocationTargetException e) {
      throw new RuntimeException("writeObject failed", e);
    }
  }

  @Override
  public T read(MemoryBuffer buffer) {
    T result = fieldSerializer.read(buffer);
    if (result != null) {
      inputWrapper.set(buffer, fory);
      try {
        readMethod.invoke(result, inputWrapper);
      } catch (IllegalAccessException | InvocationTargetException e) {
        throw new RuntimeException("readObject failed", e);
      }
    }

    return result;
  }

  /**
   * Register serializer for a given fastutil class.
   *
   * @param fory Fory instance
   * @param fastutilClass Fastutil class
   */
  public static void register(Fory fory, Class<?> fastutilClass) {

    if (Collections.class.isAssignableFrom(fastutilClass)) {
      fory.registerSerializer(fastutilClass, new FastUtilCollectionSerializer(fory, fastutilClass));
      return;
    }

    if (Map.class.isAssignableFrom(fastutilClass)) {
      fory.registerSerializer(
          fastutilClass, new FastUtilMapSerializer<>(fory, (Class<? extends Map>) fastutilClass));
      return;
    }

    fory.registerSerializer(fastutilClass, new FastUtilSerializer<>(fory, fastutilClass));
  }

  /**
   * Registers serializers for all possible fastutil classes.
   *
   * <p>There are many fastutil classes, so it is recommended to call this function at the end, so
   * they fastutil classes don't use up small registration numbers.
   *
   * @param fory Fory instance
   */
  public static void registerAll(Fory fory) {
    registerArrayLists(fory);
    registerArrayBigList(fory);
    registerOpenHashSets(fory);
    registerArraySets(fory);
    registerRBTreeSets(fory);
    registerAVLTreeSets(fory);
    registerOpenHashMaps(fory);
    registerRBTreeMaps(fory);
    registerAVLTreeMaps(fory);

    // Note - HeapPriorityQueues don't extend boxed collection,
    // and so they work out of the box correctly
  }

  /**
   * Register all Fastutil ArrayLists.
   *
   * @param fory Fory instance
   */
  public static void registerArrayLists(Fory fory) {
    registerCollection(
        fory, singleTypes("it.unimi.dsi.fastutil._t1_s._T1_ArrayList", PRIMITIVE_TYPES));
  }

  /**
   * Register all Fastutil ArrayBigLists.
   *
   * @param fory Fory instance
   */
  public static void registerArrayBigList(Fory fory) {
    registerCollection(
        fory, singleTypes("it.unimi.dsi.fastutil._t1_s._T1_BigArrayBigList", PRIMITIVE_TYPES));
  }

  /**
   * Register all Fastutil OpenHashSets.
   *
   * @param fory Fory instance
   */
  public static void registerOpenHashSets(Fory fory) {
    registerCollection(
        fory, singleTypes("it.unimi.dsi.fastutil._t1_s._T1_OpenHashSet", PRIMITIVE_TYPES));
  }

  /**
   * Register all Fastutil ArraySets.
   *
   * @param fory Fory instance
   */
  public static void registerArraySets(Fory fory) {
    registerCollection(
        fory, singleTypes("it.unimi.dsi.fastutil._t1_s._T1_ArraySet", PRIMITIVE_TYPES));
  }

  /**
   * Register all Fastutil RBTreeSets.
   *
   * @param fory Fory instance
   */
  public static void registerRBTreeSets(Fory fory) {
    registerCollection(
        fory, singleTypes("it.unimi.dsi.fastutil._t1_s._T1_RBTreeSet", PRIMITIVE_KEY_TYPES));
  }

  /**
   * Register all Fastutil AVLTreeSets.
   *
   * @param fory Fory instance
   */
  public static void registerAVLTreeSets(Fory fory) {
    registerCollection(
        fory, singleTypes("it.unimi.dsi.fastutil._t1_s._T1_AVLTreeSet", PRIMITIVE_KEY_TYPES));
  }

  /**
   * Register all Fastutil OpenHashMaps.
   *
   * @param fory Fory instance
   */
  public static void registerOpenHashMaps(Fory fory) {
    registerMap(
        fory,
        doubleTypes(
            "it.unimi.dsi.fastutil._t1_s._T1_2_T2_OpenHashMap",
            PRIMITIVE_KEY_TYPES,
            PRIMITIVE_TYPES));
  }

  /**
   * Register all Fastutil RBTreeMaps.
   *
   * @param fory Fory instance
   */
  public static void registerRBTreeMaps(Fory fory) {
    registerMap(
        fory,
        doubleTypes(
            "it.unimi.dsi.fastutil._t1_s._T1_2_T2_RBTreeMap",
            PRIMITIVE_KEY_TYPES,
            PRIMITIVE_TYPES));
  }

  /**
   * Register all Fastutil AVLTreeMaps.
   *
   * @param fory Fory instance
   */
  public static void registerAVLTreeMaps(Fory fory) {
    registerMap(
        fory,
        doubleTypes(
            "it.unimi.dsi.fastutil._t1_s._T1_2_T2_AVLTreeMap",
            PRIMITIVE_KEY_TYPES,
            PRIMITIVE_TYPES));
  }

  /**
   * Register all class from the list of classes.
   *
   * @param fory Fory instance
   * @param types List of classes
   */
  private static void registerCollection(Fory fory, ArrayList<Class<?>> types) {
    for (Class<?> type : types) {
      fory.registerSerializer(type, new FastUtilCollectionSerializer(fory, type));
    }
  }

  /**
   * Register all class from the list of classes.
   *
   * @param fory Fory instance
   * @param types List of classes
   */
  private static void registerMap(Fory fory, ArrayList<Class<?>> types) {
    for (Class<?> type : types) {
      fory.registerSerializer(type, new FastUtilMapSerializer<>(fory, (Class<? extends Map>) type));
    }
  }

  /**
   * Returns list of all classes that are generated by using given pattern, and replacing it with
   * passed list of types. Pattern contains _t1_ and _T1_, for lowercase and actual name.
   *
   * @param pattern Given pattern
   * @param types Given list of strings to replace into pattern
   * @return List of all classes
   */
  private static ArrayList<Class<?>> singleTypes(String pattern, String[] types) {
    ArrayList<Class<?>> result = new ArrayList<>();

    for (String type : types) {
      try {
        result.add(
            Class.forName(pattern.replaceAll("_T1_", type).replaceAll("_t1_", type.toLowerCase())));
      } catch (ClassNotFoundException e) {
        throw new RuntimeException(pattern + " " + type, e);
      }
    }
    return result;
  }

  /**
   * Returns list of all classes that are generated by using given pattern, and replacing it with
   * passed list of types. Pattern contains two variable pairs: _t1_, _T1_ and _t2_, _T2_, in each
   * pair one for lowercase and one for actual name.
   *
   * @param pattern Given pattern
   * @param types1 Given list of strings to replace t1 into pattern
   * @param types2 Given list of strings to replace t2 into pattern
   * @return List of all classes
   */
  private static ArrayList<Class<?>> doubleTypes(String pattern, String[] types1, String[] types2) {
    ArrayList<Class<?>> result = new ArrayList<>();

    for (String type1 : types1) {
      for (String type2 : types2) {
        try {
          result.add(
              Class.forName(
                  pattern
                      .replaceAll("_T1_", type1)
                      .replaceAll("_t1_", type1.toLowerCase())
                      .replaceAll("_T2_", type2)
                      .replaceAll("_t2_", type2.toLowerCase())));
        } catch (ClassNotFoundException e) {
          throw new RuntimeException(pattern + " " + type1 + " " + type2, e);
        }
      }
    }
    return result;
  }

  /**
   * Wrapper around ObjectOutputStream that ignores defaultWriteObject (assumes that needed logic
   * was already executed before), and passes all other calls to Output.
   */
  private static class FastutilObjectOutputStream extends ObjectOutputStream {
    private MemoryBuffer buffer;

    private Fory fory;

    FastutilObjectOutputStream() throws IOException {
      super();
    }

    public void set(MemoryBuffer output, Fory fory) {
      this.buffer = output;
      this.fory = fory;
    }

    @Override
    public void defaultWriteObject() {}

    @Override
    public void writeBoolean(boolean val) {
      buffer.writeBoolean(val);
    }

    @Override
    public void writeByte(int val) {
      buffer.writeByte(val);
    }

    @Override
    public void writeShort(int val) {
      buffer.writeVarInt32(val);
    }

    @Override
    public void writeChar(int val) {
      buffer.writeChar((char) val);
    }

    @Override
    public void writeInt(int val) {
      buffer.writeVarInt32(val);
    }

    @Override
    public void writeLong(long val) {
      buffer.writeVarInt64(val);
    }

    @Override
    public void writeFloat(float val) {
      buffer.writeFloat32(val);
    }

    @Override
    public void writeDouble(double val) {
      buffer.writeFloat64(val);
    }

    @Override
    protected void writeObjectOverride(Object obj) {
      fory.writeRef(buffer, obj);
    }
  }

  /**
   * Wrapper around ObjectOutputStream that ignores defaultReadObject (assumes that needed logic was
   * already executed before), and passes all other calls to Output.
   */
  private static class FastutilObjectInputStream extends ObjectInputStream {

    private MemoryBuffer buffer;

    private Fory fory;

    FastutilObjectInputStream() throws IOException {
      super();
    }

    public void set(MemoryBuffer buffer, Fory fory) {
      this.buffer = buffer;
      this.fory = fory;
    }

    @Override
    public void defaultReadObject() {}

    @Override
    public boolean readBoolean() {
      return buffer.readBoolean();
    }

    @Override
    public byte readByte() {
      return buffer.readByte();
    }

    @Override
    public char readChar() {
      return buffer.readChar();
    }

    @Override
    public short readShort() {
      return (short) buffer.readVarInt32();
    }

    @Override
    public int readInt() {
      return buffer.readVarInt32();
    }

    @Override
    public long readLong() {
      return buffer.readVarInt64();
    }

    @Override
    public float readFloat() {
      return buffer.readFloat32();
    }

    @Override
    public double readDouble() {
      return buffer.readFloat64();
    }

    @Override
    protected Object readObjectOverride() {
      return fory.readRef(buffer);
    }
  }

  public static class FastUtilMapSerializer<T extends Map> extends MapSerializer<T> {
    private final Serializer serializer;

    public FastUtilMapSerializer(Fory fory, Class<T> cls) {
      super(fory, cls, false);
      this.serializer = new FastUtilSerializer<>(fory, cls);
    }

    @Override
    public Map onMapWrite(MemoryBuffer buffer, T value) {
      throw new IllegalStateException();
    }

    @Override
    public T onMapCopy(Map map) {
      throw new IllegalStateException();
    }

    @Override
    public T onMapRead(Map map) {
      throw new IllegalStateException();
    }

    @SuppressWarnings("unchecked")
    @Override
    public T read(MemoryBuffer buffer) {
      return (T) serializer.read(buffer);
    }

    @Override
    public void write(MemoryBuffer buffer, T value) {
      serializer.write(buffer, value);
    }

    @Override
    public T copy(T value) {
      return fory.copyObject(value, (Serializer<T>) serializer);
    }
  }

  /** Collection serializer for class with JDK custom serialization methods defined. */
  public static final class FastUtilCollectionSerializer<T extends Collection<?>>
      extends CollectionSerializer<T> {
    private final Serializer serializer;

    public FastUtilCollectionSerializer(Fory fory, Class<T> cls) {
      super(fory, cls, false);
      this.serializer = new FastUtilSerializer<>(fory, cls);
    }

    @Override
    public Collection onCollectionWrite(MemoryBuffer buffer, T value) {
      throw new IllegalStateException();
    }

    @SuppressWarnings("unchecked")
    @Override
    public T read(MemoryBuffer buffer) {
      return (T) serializer.read(buffer);
    }

    @Override
    public T onCollectionRead(Collection collection) {
      throw new IllegalStateException();
    }

    @Override
    public void write(MemoryBuffer buffer, T value) {
      serializer.write(buffer, value);
    }

    @Override
    public T copy(T value) {
      return super.copy(value);
    }
  }
}
