// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bench.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Protobuf_Player: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case java // = 0
  case flash // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .java
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .java
    case 1: self = .flash
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .java: return 0
    case .flash: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Protobuf_Player] = [
    .java,
    .flash,
  ]

}

public enum Protobuf_Size: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case small // = 0
  case large // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .small
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .small
    case 1: self = .large
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .small: return 0
    case .large: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Protobuf_Size] = [
    .small,
    .large,
  ]

}

public struct Protobuf_Foo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var f1: String {
    get {_f1 ?? String()}
    set {_f1 = newValue}
  }
  /// Returns true if `f1` has been explicitly set.
  public var hasF1: Bool {self._f1 != nil}
  /// Clears the value of `f1`. Subsequent reads from it will return its default value.
  public mutating func clearF1() {self._f1 = nil}

  public var f2: Dictionary<String,Int32> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _f1: String? = nil
}

public struct Protobuf_Bar: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var f1: Protobuf_Foo {
    get {_f1 ?? Protobuf_Foo()}
    set {_f1 = newValue}
  }
  /// Returns true if `f1` has been explicitly set.
  public var hasF1: Bool {self._f1 != nil}
  /// Clears the value of `f1`. Subsequent reads from it will return its default value.
  public mutating func clearF1() {self._f1 = nil}

  public var f2: String {
    get {_f2 ?? String()}
    set {_f2 = newValue}
  }
  /// Returns true if `f2` has been explicitly set.
  public var hasF2: Bool {self._f2 != nil}
  /// Clears the value of `f2`. Subsequent reads from it will return its default value.
  public mutating func clearF2() {self._f2 = nil}

  public var f3: [Protobuf_Foo] = []

  public var f4: Dictionary<Int32,Protobuf_Foo> = [:]

  public var f5: Int32 {
    get {_f5 ?? 0}
    set {_f5 = newValue}
  }
  /// Returns true if `f5` has been explicitly set.
  public var hasF5: Bool {self._f5 != nil}
  /// Clears the value of `f5`. Subsequent reads from it will return its default value.
  public mutating func clearF5() {self._f5 = nil}

  public var f6: Int64 {
    get {_f6 ?? 0}
    set {_f6 = newValue}
  }
  /// Returns true if `f6` has been explicitly set.
  public var hasF6: Bool {self._f6 != nil}
  /// Clears the value of `f6`. Subsequent reads from it will return its default value.
  public mutating func clearF6() {self._f6 = nil}

  public var f7: Float {
    get {_f7 ?? 0}
    set {_f7 = newValue}
  }
  /// Returns true if `f7` has been explicitly set.
  public var hasF7: Bool {self._f7 != nil}
  /// Clears the value of `f7`. Subsequent reads from it will return its default value.
  public mutating func clearF7() {self._f7 = nil}

  public var f8: Double {
    get {_f8 ?? 0}
    set {_f8 = newValue}
  }
  /// Returns true if `f8` has been explicitly set.
  public var hasF8: Bool {self._f8 != nil}
  /// Clears the value of `f8`. Subsequent reads from it will return its default value.
  public mutating func clearF8() {self._f8 = nil}

  /// proto does not support int16
  public var f9: [Int32] = []

  public var f10: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _f1: Protobuf_Foo? = nil
  fileprivate var _f2: String? = nil
  fileprivate var _f5: Int32? = nil
  fileprivate var _f6: Int64? = nil
  fileprivate var _f7: Float? = nil
  fileprivate var _f8: Double? = nil
}

public struct Protobuf_Sample: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var intValue: Int32 {
    get {_storage._intValue}
    set {_uniqueStorage()._intValue = newValue}
  }

  public var longValue: Int64 {
    get {_storage._longValue}
    set {_uniqueStorage()._longValue = newValue}
  }

  public var floatValue: Float {
    get {_storage._floatValue}
    set {_uniqueStorage()._floatValue = newValue}
  }

  public var doubleValue: Double {
    get {_storage._doubleValue}
    set {_uniqueStorage()._doubleValue = newValue}
  }

  public var shortValue: Int32 {
    get {_storage._shortValue}
    set {_uniqueStorage()._shortValue = newValue}
  }

  public var charValue: Int32 {
    get {_storage._charValue}
    set {_uniqueStorage()._charValue = newValue}
  }

  public var booleanValue: Bool {
    get {_storage._booleanValue}
    set {_uniqueStorage()._booleanValue = newValue}
  }

  public var intValueBoxed: Int32 {
    get {_storage._intValueBoxed}
    set {_uniqueStorage()._intValueBoxed = newValue}
  }

  public var longValueBoxed: Int64 {
    get {_storage._longValueBoxed}
    set {_uniqueStorage()._longValueBoxed = newValue}
  }

  public var floatValueBoxed: Float {
    get {_storage._floatValueBoxed}
    set {_uniqueStorage()._floatValueBoxed = newValue}
  }

  public var doubleValueBoxed: Double {
    get {_storage._doubleValueBoxed}
    set {_uniqueStorage()._doubleValueBoxed = newValue}
  }

  public var shortValueBoxed: Int32 {
    get {_storage._shortValueBoxed}
    set {_uniqueStorage()._shortValueBoxed = newValue}
  }

  public var charValueBoxed: Int32 {
    get {_storage._charValueBoxed}
    set {_uniqueStorage()._charValueBoxed = newValue}
  }

  public var booleanValueBoxed: Bool {
    get {_storage._booleanValueBoxed}
    set {_uniqueStorage()._booleanValueBoxed = newValue}
  }

  public var intArray: [Int32] {
    get {_storage._intArray}
    set {_uniqueStorage()._intArray = newValue}
  }

  public var longArray: [Int64] {
    get {_storage._longArray}
    set {_uniqueStorage()._longArray = newValue}
  }

  public var floatArray: [Float] {
    get {_storage._floatArray}
    set {_uniqueStorage()._floatArray = newValue}
  }

  public var doubleArray: [Double] {
    get {_storage._doubleArray}
    set {_uniqueStorage()._doubleArray = newValue}
  }

  public var shortArray: [Int32] {
    get {_storage._shortArray}
    set {_uniqueStorage()._shortArray = newValue}
  }

  public var charArray: [Int32] {
    get {_storage._charArray}
    set {_uniqueStorage()._charArray = newValue}
  }

  public var booleanArray: [Bool] {
    get {_storage._booleanArray}
    set {_uniqueStorage()._booleanArray = newValue}
  }

  public var string: String {
    get {_storage._string}
    set {_uniqueStorage()._string = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protobuf_SampleList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sampleList: [Protobuf_Sample] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protobuf_MediaContent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var media: Protobuf_Media {
    get {_media ?? Protobuf_Media()}
    set {_media = newValue}
  }
  /// Returns true if `media` has been explicitly set.
  public var hasMedia: Bool {self._media != nil}
  /// Clears the value of `media`. Subsequent reads from it will return its default value.
  public mutating func clearMedia() {self._media = nil}

  public var images: [Protobuf_Image] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _media: Protobuf_Media? = nil
}

public struct Protobuf_MediaContentList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mediaContentList: [Protobuf_MediaContent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protobuf_Media: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uri: String = String()

  public var title: String {
    get {_title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var width: Int32 = 0

  public var height: Int32 = 0

  public var format: String = String()

  public var duration: Int64 = 0

  public var size: Int64 = 0

  public var bitrate: Int32 = 0

  public var hasBitrate_p: Bool = false

  public var persons: [String] = []

  public var player: Protobuf_Player = .java

  public var copyright: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _title: String? = nil
}

public struct Protobuf_Image: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uri: String {
    get {_storage._uri}
    set {_uniqueStorage()._uri = newValue}
  }

  /// Can be null.
  public var title: String {
    get {_storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {_storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {_uniqueStorage()._title = nil}

  public var width: Int32 {
    get {_storage._width}
    set {_uniqueStorage()._width = newValue}
  }

  public var height: Int32 {
    get {_storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var size: Protobuf_Size {
    get {_storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// Can be null.
  public var media: Protobuf_Media {
    get {_storage._media ?? Protobuf_Media()}
    set {_uniqueStorage()._media = newValue}
  }
  /// Returns true if `media` has been explicitly set.
  public var hasMedia: Bool {_storage._media != nil}
  /// Clears the value of `media`. Subsequent reads from it will return its default value.
  public mutating func clearMedia() {_uniqueStorage()._media = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protobuf_Struct: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var f1: Int32 = 0

  public var f2: Int32 = 0

  public var f3: Int32 = 0

  public var f4: Int32 = 0

  public var f5: Int32 = 0

  public var f6: Int32 = 0

  public var f7: Int32 = 0

  public var f8: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protobuf_StructList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var structList: [Protobuf_Struct] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protobuf"

extension Protobuf_Player: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0JAVA\0\u{1}FLASH\0")
}

extension Protobuf_Size: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SMALL\0\u{1}LARGE\0")
}

extension Protobuf_Foo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Foo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}f1\0\u{1}f2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._f1) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.f2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._f1 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.f2.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.f2, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_Foo, rhs: Protobuf_Foo) -> Bool {
    if lhs._f1 != rhs._f1 {return false}
    if lhs.f2 != rhs.f2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protobuf_Bar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Bar"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}f1\0\u{1}f2\0\u{1}f3\0\u{1}f4\0\u{1}f5\0\u{1}f6\0\u{1}f7\0\u{1}f8\0\u{1}f9\0\u{1}f10\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._f1) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._f2) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.f3) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Protobuf_Foo>.self, value: &self.f4) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._f5) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self._f6) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._f7) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self._f8) }()
      case 9: try { try decoder.decodeRepeatedInt32Field(value: &self.f9) }()
      case 10: try { try decoder.decodeRepeatedInt64Field(value: &self.f10) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._f1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._f2 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.f3.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.f3, fieldNumber: 3)
    }
    if !self.f4.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Protobuf_Foo>.self, value: self.f4, fieldNumber: 4)
    }
    try { if let v = self._f5 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._f6 {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._f7 {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._f8 {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 8)
    } }()
    if !self.f9.isEmpty {
      try visitor.visitPackedInt32Field(value: self.f9, fieldNumber: 9)
    }
    if !self.f10.isEmpty {
      try visitor.visitPackedInt64Field(value: self.f10, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_Bar, rhs: Protobuf_Bar) -> Bool {
    if lhs._f1 != rhs._f1 {return false}
    if lhs._f2 != rhs._f2 {return false}
    if lhs.f3 != rhs.f3 {return false}
    if lhs.f4 != rhs.f4 {return false}
    if lhs._f5 != rhs._f5 {return false}
    if lhs._f6 != rhs._f6 {return false}
    if lhs._f7 != rhs._f7 {return false}
    if lhs._f8 != rhs._f8 {return false}
    if lhs.f9 != rhs.f9 {return false}
    if lhs.f10 != rhs.f10 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protobuf_Sample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sample"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}int_value\0\u{3}long_value\0\u{3}float_value\0\u{3}double_value\0\u{3}short_value\0\u{3}char_value\0\u{3}boolean_value\0\u{3}int_value_boxed\0\u{3}long_value_boxed\0\u{3}float_value_boxed\0\u{3}double_value_boxed\0\u{3}short_value_boxed\0\u{3}char_value_boxed\0\u{3}boolean_value_boxed\0\u{3}int_array\0\u{3}long_array\0\u{3}float_array\0\u{3}double_array\0\u{3}short_array\0\u{3}char_array\0\u{3}boolean_array\0\u{1}string\0")

  fileprivate class _StorageClass {
    var _intValue: Int32 = 0
    var _longValue: Int64 = 0
    var _floatValue: Float = 0
    var _doubleValue: Double = 0
    var _shortValue: Int32 = 0
    var _charValue: Int32 = 0
    var _booleanValue: Bool = false
    var _intValueBoxed: Int32 = 0
    var _longValueBoxed: Int64 = 0
    var _floatValueBoxed: Float = 0
    var _doubleValueBoxed: Double = 0
    var _shortValueBoxed: Int32 = 0
    var _charValueBoxed: Int32 = 0
    var _booleanValueBoxed: Bool = false
    var _intArray: [Int32] = []
    var _longArray: [Int64] = []
    var _floatArray: [Float] = []
    var _doubleArray: [Double] = []
    var _shortArray: [Int32] = []
    var _charArray: [Int32] = []
    var _booleanArray: [Bool] = []
    var _string: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _intValue = source._intValue
      _longValue = source._longValue
      _floatValue = source._floatValue
      _doubleValue = source._doubleValue
      _shortValue = source._shortValue
      _charValue = source._charValue
      _booleanValue = source._booleanValue
      _intValueBoxed = source._intValueBoxed
      _longValueBoxed = source._longValueBoxed
      _floatValueBoxed = source._floatValueBoxed
      _doubleValueBoxed = source._doubleValueBoxed
      _shortValueBoxed = source._shortValueBoxed
      _charValueBoxed = source._charValueBoxed
      _booleanValueBoxed = source._booleanValueBoxed
      _intArray = source._intArray
      _longArray = source._longArray
      _floatArray = source._floatArray
      _doubleArray = source._doubleArray
      _shortArray = source._shortArray
      _charArray = source._charArray
      _booleanArray = source._booleanArray
      _string = source._string
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._intValue) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._longValue) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._floatValue) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._doubleValue) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._shortValue) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._charValue) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._booleanValue) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._intValueBoxed) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._longValueBoxed) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._floatValueBoxed) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._doubleValueBoxed) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._shortValueBoxed) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._charValueBoxed) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._booleanValueBoxed) }()
        case 15: try { try decoder.decodeRepeatedInt32Field(value: &_storage._intArray) }()
        case 16: try { try decoder.decodeRepeatedInt64Field(value: &_storage._longArray) }()
        case 17: try { try decoder.decodeRepeatedFloatField(value: &_storage._floatArray) }()
        case 18: try { try decoder.decodeRepeatedDoubleField(value: &_storage._doubleArray) }()
        case 19: try { try decoder.decodeRepeatedInt32Field(value: &_storage._shortArray) }()
        case 20: try { try decoder.decodeRepeatedInt32Field(value: &_storage._charArray) }()
        case 21: try { try decoder.decodeRepeatedBoolField(value: &_storage._booleanArray) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._string) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._intValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._intValue, fieldNumber: 1)
      }
      if _storage._longValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._longValue, fieldNumber: 2)
      }
      if _storage._floatValue.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._floatValue, fieldNumber: 3)
      }
      if _storage._doubleValue.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._doubleValue, fieldNumber: 4)
      }
      if _storage._shortValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._shortValue, fieldNumber: 5)
      }
      if _storage._charValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._charValue, fieldNumber: 6)
      }
      if _storage._booleanValue != false {
        try visitor.visitSingularBoolField(value: _storage._booleanValue, fieldNumber: 7)
      }
      if _storage._intValueBoxed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._intValueBoxed, fieldNumber: 8)
      }
      if _storage._longValueBoxed != 0 {
        try visitor.visitSingularInt64Field(value: _storage._longValueBoxed, fieldNumber: 9)
      }
      if _storage._floatValueBoxed.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._floatValueBoxed, fieldNumber: 10)
      }
      if _storage._doubleValueBoxed.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._doubleValueBoxed, fieldNumber: 11)
      }
      if _storage._shortValueBoxed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._shortValueBoxed, fieldNumber: 12)
      }
      if _storage._charValueBoxed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._charValueBoxed, fieldNumber: 13)
      }
      if _storage._booleanValueBoxed != false {
        try visitor.visitSingularBoolField(value: _storage._booleanValueBoxed, fieldNumber: 14)
      }
      if !_storage._intArray.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._intArray, fieldNumber: 15)
      }
      if !_storage._longArray.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._longArray, fieldNumber: 16)
      }
      if !_storage._floatArray.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._floatArray, fieldNumber: 17)
      }
      if !_storage._doubleArray.isEmpty {
        try visitor.visitPackedDoubleField(value: _storage._doubleArray, fieldNumber: 18)
      }
      if !_storage._shortArray.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._shortArray, fieldNumber: 19)
      }
      if !_storage._charArray.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._charArray, fieldNumber: 20)
      }
      if !_storage._booleanArray.isEmpty {
        try visitor.visitPackedBoolField(value: _storage._booleanArray, fieldNumber: 21)
      }
      if !_storage._string.isEmpty {
        try visitor.visitSingularStringField(value: _storage._string, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_Sample, rhs: Protobuf_Sample) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._intValue != rhs_storage._intValue {return false}
        if _storage._longValue != rhs_storage._longValue {return false}
        if _storage._floatValue != rhs_storage._floatValue {return false}
        if _storage._doubleValue != rhs_storage._doubleValue {return false}
        if _storage._shortValue != rhs_storage._shortValue {return false}
        if _storage._charValue != rhs_storage._charValue {return false}
        if _storage._booleanValue != rhs_storage._booleanValue {return false}
        if _storage._intValueBoxed != rhs_storage._intValueBoxed {return false}
        if _storage._longValueBoxed != rhs_storage._longValueBoxed {return false}
        if _storage._floatValueBoxed != rhs_storage._floatValueBoxed {return false}
        if _storage._doubleValueBoxed != rhs_storage._doubleValueBoxed {return false}
        if _storage._shortValueBoxed != rhs_storage._shortValueBoxed {return false}
        if _storage._charValueBoxed != rhs_storage._charValueBoxed {return false}
        if _storage._booleanValueBoxed != rhs_storage._booleanValueBoxed {return false}
        if _storage._intArray != rhs_storage._intArray {return false}
        if _storage._longArray != rhs_storage._longArray {return false}
        if _storage._floatArray != rhs_storage._floatArray {return false}
        if _storage._doubleArray != rhs_storage._doubleArray {return false}
        if _storage._shortArray != rhs_storage._shortArray {return false}
        if _storage._charArray != rhs_storage._charArray {return false}
        if _storage._booleanArray != rhs_storage._booleanArray {return false}
        if _storage._string != rhs_storage._string {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protobuf_SampleList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SampleList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sample_list\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sampleList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sampleList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sampleList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_SampleList, rhs: Protobuf_SampleList) -> Bool {
    if lhs.sampleList != rhs.sampleList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protobuf_MediaContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaContent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}media\0\u{1}images\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._media) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._media {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_MediaContent, rhs: Protobuf_MediaContent) -> Bool {
    if lhs._media != rhs._media {return false}
    if lhs.images != rhs.images {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protobuf_MediaContentList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaContentList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}media_content_list\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mediaContentList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaContentList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mediaContentList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_MediaContentList, rhs: Protobuf_MediaContentList) -> Bool {
    if lhs.mediaContentList != rhs.mediaContentList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protobuf_Media: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Media"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uri\0\u{1}title\0\u{1}width\0\u{1}height\0\u{1}format\0\u{1}duration\0\u{1}size\0\u{1}bitrate\0\u{3}has_bitrate\0\u{1}persons\0\u{1}player\0\u{1}copyright\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.bitrate) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.hasBitrate_p) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.persons) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.player) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.copyright) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 5)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 6)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 7)
    }
    if self.bitrate != 0 {
      try visitor.visitSingularInt32Field(value: self.bitrate, fieldNumber: 8)
    }
    if self.hasBitrate_p != false {
      try visitor.visitSingularBoolField(value: self.hasBitrate_p, fieldNumber: 9)
    }
    if !self.persons.isEmpty {
      try visitor.visitRepeatedStringField(value: self.persons, fieldNumber: 10)
    }
    if self.player != .java {
      try visitor.visitSingularEnumField(value: self.player, fieldNumber: 11)
    }
    if !self.copyright.isEmpty {
      try visitor.visitSingularStringField(value: self.copyright, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_Media, rhs: Protobuf_Media) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs._title != rhs._title {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.format != rhs.format {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.size != rhs.size {return false}
    if lhs.bitrate != rhs.bitrate {return false}
    if lhs.hasBitrate_p != rhs.hasBitrate_p {return false}
    if lhs.persons != rhs.persons {return false}
    if lhs.player != rhs.player {return false}
    if lhs.copyright != rhs.copyright {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protobuf_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Image"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uri\0\u{1}title\0\u{1}width\0\u{1}height\0\u{1}size\0\u{1}media\0")

  fileprivate class _StorageClass {
    var _uri: String = String()
    var _title: String? = nil
    var _width: Int32 = 0
    var _height: Int32 = 0
    var _size: Protobuf_Size = .small
    var _media: Protobuf_Media? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uri = source._uri
      _title = source._title
      _width = source._width
      _height = source._height
      _size = source._size
      _media = source._media
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._uri) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._width) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._height) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._size) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._media) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uri, fieldNumber: 1)
      }
      try { if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      if _storage._width != 0 {
        try visitor.visitSingularInt32Field(value: _storage._width, fieldNumber: 3)
      }
      if _storage._height != 0 {
        try visitor.visitSingularInt32Field(value: _storage._height, fieldNumber: 4)
      }
      if _storage._size != .small {
        try visitor.visitSingularEnumField(value: _storage._size, fieldNumber: 5)
      }
      try { if let v = _storage._media {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_Image, rhs: Protobuf_Image) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uri != rhs_storage._uri {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._media != rhs_storage._media {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protobuf_Struct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Struct"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}f1\0\u{1}f2\0\u{1}f3\0\u{1}f4\0\u{1}f5\0\u{1}f6\0\u{1}f7\0\u{1}f8\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.f1) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.f2) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.f3) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.f4) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.f5) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.f6) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.f7) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.f8) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.f1 != 0 {
      try visitor.visitSingularInt32Field(value: self.f1, fieldNumber: 1)
    }
    if self.f2 != 0 {
      try visitor.visitSingularInt32Field(value: self.f2, fieldNumber: 2)
    }
    if self.f3 != 0 {
      try visitor.visitSingularInt32Field(value: self.f3, fieldNumber: 3)
    }
    if self.f4 != 0 {
      try visitor.visitSingularInt32Field(value: self.f4, fieldNumber: 4)
    }
    if self.f5 != 0 {
      try visitor.visitSingularInt32Field(value: self.f5, fieldNumber: 5)
    }
    if self.f6 != 0 {
      try visitor.visitSingularInt32Field(value: self.f6, fieldNumber: 6)
    }
    if self.f7 != 0 {
      try visitor.visitSingularInt32Field(value: self.f7, fieldNumber: 7)
    }
    if self.f8 != 0 {
      try visitor.visitSingularInt32Field(value: self.f8, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_Struct, rhs: Protobuf_Struct) -> Bool {
    if lhs.f1 != rhs.f1 {return false}
    if lhs.f2 != rhs.f2 {return false}
    if lhs.f3 != rhs.f3 {return false}
    if lhs.f4 != rhs.f4 {return false}
    if lhs.f5 != rhs.f5 {return false}
    if lhs.f6 != rhs.f6 {return false}
    if lhs.f7 != rhs.f7 {return false}
    if lhs.f8 != rhs.f8 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protobuf_StructList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}struct_list\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.structList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.structList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.structList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protobuf_StructList, rhs: Protobuf_StructList) -> Bool {
    if lhs.structList != rhs.structList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
