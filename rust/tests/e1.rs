mod test_struct {
    use fory_core::fory::Fory;
    use fory_core::{
        Error, ForyDefault, ReadContext, Serializer, TypeResolver, WriteContext,
    };
    use fory_derive::ForyObject;
    use std::collections::{HashMap, HashSet};
    use std::marker::PhantomData;
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::simple"]
    #[doc(hidden)]
    pub const simple: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::simple"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 26usize,
            start_col: 4usize,
            end_line: 26usize,
            end_col: 10usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(simple()),
        ),
    };
    fn simple() {
        struct Animal1 {
            f1: HashMap<i8, Vec<i8>>,
            f2: String,
            f3: Vec<i8>,
            f5: String,
            f6: Vec<i8>,
            f7: i8,
            last: i8,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Animal1 {
            fn fory_default() -> Self {
                Self {
                    f7: <i8 as fory_core::ForyDefault>::fory_default(),
                    last: <i8 as fory_core::ForyDefault>::fory_default(),
                    f2: <String as fory_core::ForyDefault>::fory_default(),
                    f5: <String as fory_core::ForyDefault>::fory_default(),
                    f3: <Vec<i8> as fory_core::ForyDefault>::fory_default(),
                    f6: <Vec<i8> as fory_core::ForyDefault>::fory_default(),
                    f1: <HashMap<i8, Vec<i8>> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Animal1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                1u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f7", "last", "f2", "f5", "f3", "f6", "f1"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f7",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = 42u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = 42u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        Vec<i8>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = 42u32;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f7", "last", "f2", "f5", "f3", "f6", "f1"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f7: i8 = 0 as i8;
                let mut _last: i8 = 0 as i8;
                let mut _f2: Option<String> = None;
                let mut _f5: Option<String> = None;
                let mut _f3: Option<Vec<i8>> = None;
                let mut _f6: Option<Vec<i8>> = None;
                let mut _f1: Option<HashMap<i8, Vec<i8>>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f7 = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f7 = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = Some(
                                        <String as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f2 = Some(
                                        <String as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            3i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = Some(
                                        <String as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f5 = Some(
                                        <String as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            4i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <Vec<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            5i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f6 = Some(
                                        <Vec<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f6 = Some(
                                        <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            6i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = Some(
                                        <HashMap<
                                            i8,
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f1 = Some(
                                        <HashMap<
                                            i8,
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        f7: _f7,
                        last: _last,
                        f2: _f2
                            .unwrap_or_else(|| <String as fory_core::ForyDefault>::fory_default()),
                        f5: _f5
                            .unwrap_or_else(|| <String as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Vec<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Vec<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f1: _f1
                            .unwrap_or_else(|| <HashMap<
                                i8,
                                Vec<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Animal1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 1u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <String as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <String as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashMap<
                        i8,
                        Vec<i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -77824070i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,22,0,0;f2,19,0,0;f3,42,0,0;f5,19,0,0;f6,42,0,0;f7,2,0,0;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_i8(self.f7);
                context.writer.write_i8(self.last);
                <String as fory_core::Serializer>::fory_write_data(&self.f2, context)?;
                <String as fory_core::Serializer>::fory_write_data(&self.f5, context)?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Vec<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Vec<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Vec<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Vec<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Vec<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Vec<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                <HashMap<
                    i8,
                    Vec<i8>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f1,
                    context,
                    true,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -77824070i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,22,0,0;f2,19,0,0;f3,42,0,0;f5,19,0,0;f6,42,0,0;f7,2,0,0;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f7 = context.reader.read_i8()?;
                let _last = context.reader.read_i8()?;
                let _f2 = <String as fory_core::Serializer>::fory_read_data(context)?;
                let _f5 = <String as fory_core::Serializer>::fory_read_data(context)?;
                let _f3 = <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?;
                let _f6 = <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?;
                let _f1 = <HashMap<
                    i8,
                    Vec<i8>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                Ok(Self {
                    f7: _f7,
                    last: _last,
                    f2: _f2,
                    f5: _f5,
                    f3: _f3,
                    f6: _f6,
                    f1: _f1,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Animal1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &["f1", "f2", "f3", "f5", "f6", "f7", "last"];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f2,
                    &self.f3,
                    &self.f5,
                    &self.f6,
                    &self.f7,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Animal1",
                    names,
                    values,
                )
            }
        }
        struct Animal2 {
            f1: HashMap<i8, Vec<i8>>,
            f3: Vec<i8>,
            f4: String,
            f5: i8,
            f6: Vec<i16>,
            f7: i16,
            last: i8,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Animal2 {
            fn fory_default() -> Self {
                Self {
                    f7: <i16 as fory_core::ForyDefault>::fory_default(),
                    f5: <i8 as fory_core::ForyDefault>::fory_default(),
                    last: <i8 as fory_core::ForyDefault>::fory_default(),
                    f4: <String as fory_core::ForyDefault>::fory_default(),
                    f3: <Vec<i8> as fory_core::ForyDefault>::fory_default(),
                    f6: <Vec<i16> as fory_core::ForyDefault>::fory_default(),
                    f1: <HashMap<i8, Vec<i8>> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Animal2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                2u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f7", "f5", "last", "f4", "f3", "f6", "f1"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f7",
                            {
                                let mut ft = {
                                    let mut type_id = <i16 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = 42u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = 43u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        Vec<i8>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = 42u32;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f7", "f5", "last", "f4", "f3", "f6", "f1"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f7: i16 = 0 as i16;
                let mut _f5: i8 = 0 as i8;
                let mut _last: i8 = 0 as i8;
                let mut _f4: Option<String> = None;
                let mut _f3: Option<Vec<i8>> = None;
                let mut _f6: Option<Vec<i16>> = None;
                let mut _f1: Option<HashMap<i8, Vec<i8>>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f7 = <i16 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f7 = <i16 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f5 = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            3i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f4 = Some(
                                        <String as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f4 = Some(
                                        <String as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            4i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <Vec<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            5i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f6 = Some(
                                        <Vec<
                                            i16,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f6 = Some(
                                        <Vec<
                                            i16,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            6i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = Some(
                                        <HashMap<
                                            i8,
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f1 = Some(
                                        <HashMap<
                                            i8,
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        f7: _f7,
                        f5: _f5,
                        last: _last,
                        f4: _f4
                            .unwrap_or_else(|| <String as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Vec<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Vec<
                                i16,
                            > as fory_core::ForyDefault>::fory_default()),
                        f1: _f1
                            .unwrap_or_else(|| <HashMap<
                                i8,
                                Vec<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Animal2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 2u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i16 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <String as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<i16> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashMap<
                        i8,
                        Vec<i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = 1359984644i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,22,0,0;f3,42,0,0;f4,19,0,0;f5,2,0,0;f6,43,0,0;f7,3,0,0;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_i16(self.f7);
                context.writer.write_i8(self.f5);
                context.writer.write_i8(self.last);
                <String as fory_core::Serializer>::fory_write_data(&self.f4, context)?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Vec<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Vec<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Vec<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Vec<i16> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Vec<i16> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Vec<
                    i16,
                > as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                <HashMap<
                    i8,
                    Vec<i8>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f1,
                    context,
                    true,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = 1359984644i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,22,0,0;f3,42,0,0;f4,19,0,0;f5,2,0,0;f6,43,0,0;f7,3,0,0;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f7 = context.reader.read_i16()?;
                let _f5 = context.reader.read_i8()?;
                let _last = context.reader.read_i8()?;
                let _f4 = <String as fory_core::Serializer>::fory_read_data(context)?;
                let _f3 = <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?;
                let _f6 = <Vec<i16> as fory_core::Serializer>::fory_read_data(context)?;
                let _f1 = <HashMap<
                    i8,
                    Vec<i8>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                Ok(Self {
                    f7: _f7,
                    f5: _f5,
                    last: _last,
                    f4: _f4,
                    f3: _f3,
                    f6: _f6,
                    f1: _f1,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Animal2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &["f1", "f3", "f4", "f5", "f6", "f7", "last"];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f3,
                    &self.f4,
                    &self.f5,
                    &self.f6,
                    &self.f7,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Animal2",
                    names,
                    values,
                )
            }
        }
        let mut fory1 = Fory::default().compatible(true);
        let mut fory2 = Fory::default().compatible(true);
        fory1.register::<Animal1>(999).unwrap();
        fory2.register::<Animal2>(999).unwrap();
        let animal: Animal1 = Animal1 {
            f1: HashMap::from([(1, <[_]>::into_vec(::alloc::boxed::box_new([2])))]),
            f2: String::from("hello"),
            f3: <[_]>::into_vec(::alloc::boxed::box_new([1, 2, 3])),
            f5: String::from("f5"),
            f6: <[_]>::into_vec(::alloc::boxed::box_new([42])),
            f7: 43,
            last: 44,
        };
        let bin = fory1.serialize(&animal).unwrap();
        let obj: Animal2 = fory2.deserialize(&bin).unwrap();
        match (&animal.f1, &obj.f1) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&animal.f3, &obj.f3) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&obj.f4, &String::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&obj.f5, &i8::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&obj.f6, &Vec::<i16>::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&obj.f7, &i16::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&animal.last, &obj.last) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::skip_option"]
    #[doc(hidden)]
    pub const skip_option: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::skip_option"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 73usize,
            start_col: 4usize,
            end_line: 73usize,
            end_col: 15usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(skip_option()),
        ),
    };
    fn skip_option() {
        struct Item1 {
            f1: Option<i32>,
            f2: Option<String>,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item1 {
            fn fory_default() -> Self {
                Self {
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f1: <Option<i32> as fory_core::ForyDefault>::fory_default(),
                    f2: <Option<String> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                3u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["last", "f1", "f2"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i64 = 0 as i64;
                let mut _f1: Option<Option<i32>> = None;
                let mut _f2: Option<Option<String>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f1 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = Some(
                                        <Option<
                                            String,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f2 = Some(
                                        <Option<
                                            String,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Option<
                                i32,
                            > as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Option<
                                String,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 3u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i32> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<String> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -1840230880i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,5,0,1;f2,19,0,1;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_varint64(self.last);
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i32> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i32> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i32,
                > as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<String> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<String> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    String,
                > as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -1840230880i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,5,0,1;f2,19,0,1;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _last = context.reader.read_varint64()?;
                let _f1 = <Option<
                    i32,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f2 = <Option<
                    String,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Item1",
                    "f1",
                    &self.f1,
                    "f2",
                    &self.f2,
                    "last",
                    &&self.last,
                )
            }
        }
        struct Item2 {
            f1: i8,
            f2: i8,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item2 {
            fn fory_default() -> Self {
                Self {
                    f1: <i8 as fory_core::ForyDefault>::fory_default(),
                    f2: <i8 as fory_core::ForyDefault>::fory_default(),
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                4u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f1", "f2", "last"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f1", "f2", "last"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f1: i8 = 0 as i8;
                let mut _f2: i8 = 0 as i8;
                let mut _last: i64 = 0 as i64;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f1 = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f2 = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        f1: _f1,
                        f2: _f2,
                        last: _last,
                    })
                }
            }
        }
        impl fory_core::Serializer for Item2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 4u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -1603933263i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,2,0,0;f2,2,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_i8(self.f1);
                context.writer.write_i8(self.f2);
                context.writer.write_varint64(self.last);
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -1603933263i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,2,0,0;f2,2,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f1 = context.reader.read_i8()?;
                let _f2 = context.reader.read_i8()?;
                let _last = context.reader.read_varint64()?;
                Ok(Self {
                    f1: _f1,
                    f2: _f2,
                    last: _last,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Item2",
                    "f1",
                    &self.f1,
                    "f2",
                    &self.f2,
                    "last",
                    &&self.last,
                )
            }
        }
        let mut fory1 = Fory::default().compatible(true);
        let mut fory2 = Fory::default().compatible(true);
        fory1.register::<Item1>(999).unwrap();
        fory2.register::<Item2>(999).unwrap();
        let item1 = Item1 {
            f1: None,
            f2: Some(String::from("f2")),
            last: 42,
        };
        let bin = fory1.serialize(&item1).unwrap();
        let item2: Item2 = fory2.deserialize(&bin).unwrap();
        match (&item2.f1, &i8::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f2, &i8::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.last, &item1.last) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        }
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::nonexistent_struct"]
    #[doc(hidden)]
    pub const nonexistent_struct: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::nonexistent_struct"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 105usize,
            start_col: 4usize,
            end_line: 105usize,
            end_col: 22usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(nonexistent_struct()),
        ),
    };
    fn nonexistent_struct() {
        pub struct Item1 {
            f1: i8,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item1 {
            fn fory_default() -> Self {
                Self {
                    f1: <i8 as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                5u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f1"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f1"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f1: i8 = 0 as i8;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f1 = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self { f1: _f1 })
                }
            }
        }
        impl fory_core::Serializer for Item1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 5u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = 844541145i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_i8(self.f1);
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = 844541145i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f1 = context.reader.read_i8()?;
                Ok(Self { f1: _f1 })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Item1",
                    "f1",
                    &&self.f1,
                )
            }
        }
        pub struct Item2 {
            f1: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item2 {
            fn fory_default() -> Self {
                Self {
                    f1: <i64 as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                6u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f1"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f1"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f1: i64 = 0 as i64;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f1 = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self { f1: _f1 })
                }
            }
        }
        impl fory_core::Serializer for Item2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 6u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -401336445i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_varint64(self.f1);
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -401336445i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f1 = context.reader.read_varint64()?;
                Ok(Self { f1: _f1 })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Item2",
                    "f1",
                    &&self.f1,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Item2 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Item2 {
            #[inline]
            fn eq(&self, other: &Item2) -> bool {
                self.f1 == other.f1
            }
        }
        struct Person1 {
            f2: Item1,
            f3: i8,
            last: String,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Person1 {
            fn fory_default() -> Self {
                Self {
                    f3: <i8 as fory_core::ForyDefault>::fory_default(),
                    last: <String as fory_core::ForyDefault>::fory_default(),
                    f2: <Item1 as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Person1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                7u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f3", "last", "f2"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <Item1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f3", "last", "f2"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f3: i8 = 0 as i8;
                let mut _last: Option<String> = None;
                let mut _f2: Option<Item1> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f3 = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = Some(
                                        <String as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _last = Some(
                                        <String as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Item1 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f2 = Some(
                                    <Item1 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        f3: _f3,
                        last: _last
                            .unwrap_or_else(|| <String as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Item1 as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Person1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 7u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <String as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Item1 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -1699065885i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f2,0,0,0;f3,2,0,0;last,19,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_i8(self.f3);
                <String as fory_core::Serializer>::fory_write_data(&self.last, context)?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Item1 as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -1699065885i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f2,0,0,0;f3,2,0,0;last,19,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f3 = context.reader.read_i8()?;
                let _last = <String as fory_core::Serializer>::fory_read_data(context)?;
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f2 = <Item1 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                Ok(Self {
                    f3: _f3,
                    last: _last,
                    f2: _f2,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Person1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Person1",
                    "f2",
                    &self.f2,
                    "f3",
                    &self.f3,
                    "last",
                    &&self.last,
                )
            }
        }
        struct Person2 {
            f2: Item2,
            f3: i64,
            last: String,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Person2 {
            fn fory_default() -> Self {
                Self {
                    f3: <i64 as fory_core::ForyDefault>::fory_default(),
                    last: <String as fory_core::ForyDefault>::fory_default(),
                    f2: <Item2 as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Person2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                8u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f3", "last", "f2"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <Item2 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f3", "last", "f2"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f3: i64 = 0 as i64;
                let mut _last: Option<String> = None;
                let mut _f2: Option<Item2> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f3 = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = Some(
                                        <String as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _last = Some(
                                        <String as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Item2 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f2 = Some(
                                    <Item2 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        f3: _f3,
                        last: _last
                            .unwrap_or_else(|| <String as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Item2 as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Person2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 8u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <String as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Item2 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = 729642392i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f2,0,0,0;f3,7,0,0;last,19,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_varint64(self.f3);
                <String as fory_core::Serializer>::fory_write_data(&self.last, context)?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item2 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item2 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Item2 as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = 729642392i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f2,0,0,0;f3,7,0,0;last,19,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f3 = context.reader.read_varint64()?;
                let _last = <String as fory_core::Serializer>::fory_read_data(context)?;
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item2 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item2 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f2 = <Item2 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                Ok(Self {
                    f3: _f3,
                    last: _last,
                    f2: _f2,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Person2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Person2",
                    "f2",
                    &self.f2,
                    "f3",
                    &self.f3,
                    "last",
                    &&self.last,
                )
            }
        }
        let mut fory1 = Fory::default().compatible(true);
        let mut fory2 = Fory::default().compatible(true);
        fory1.register::<Item1>(899).unwrap();
        fory1.register::<Person1>(999).unwrap();
        fory2.register::<Item2>(799).unwrap();
        fory2.register::<Person2>(999).unwrap();
        let person = Person1 {
            f2: Item1 { f1: 42 },
            f3: 24,
            last: String::from("foo"),
        };
        let bin = fory1.serialize(&person).unwrap();
        let obj: Person2 = fory2.deserialize(&bin).unwrap();
        use fory_core::ForyDefault;
        match (&obj.f2, &Item2::fory_default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&obj.f3, &i64::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&obj.last, &person.last) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::option"]
    #[doc(hidden)]
    pub const option: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::option"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 146usize,
            start_col: 4usize,
            end_line: 146usize,
            end_col: 10usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(option()),
        ),
    };
    fn option() {
        #[fory(debug)]
        struct Animal {
            f1: Option<String>,
            f2: Option<String>,
            f3: Vec<Option<String>>,
            f5: Vec<Option<Vec<Option<String>>>>,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Animal {
            fn fory_default() -> Self {
                Self {
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f1: <Option<String> as fory_core::ForyDefault>::fory_default(),
                    f2: <Option<String> as fory_core::ForyDefault>::fory_default(),
                    f3: <Vec<Option<String>> as fory_core::ForyDefault>::fory_default(),
                    f5: <Vec<
                        Option<Vec<Option<String>>>,
                    > as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Animal {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                9u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2", "f3", "f5"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <Vec<
                                        Option<String>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <Vec<
                                        Option<Vec<Option<String>>>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <Vec<
                                                    Option<String>,
                                                > as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        {
                                                            let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                                                type_resolver,
                                                            )?;
                                                            if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                                || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                            {
                                                                type_id = fory_core::types::TypeId::UNION as u32;
                                                            }
                                                            let mut generics = ::alloc::vec::Vec::new()
                                                                as Vec<fory_core::meta::FieldType>;
                                                            if (type_id == fory_core::types::TypeId::LIST as u32
                                                                || type_id == fory_core::types::TypeId::SET as u32)
                                                                && generics.is_empty()
                                                            {
                                                                generics
                                                                    .push(
                                                                        fory_core::meta::FieldType::new(
                                                                            fory_core::types::TypeId::UNKNOWN as u32,
                                                                            true,
                                                                            ::alloc::vec::Vec::new(),
                                                                        ),
                                                                    );
                                                            }
                                                            let is_custom = !fory_core::types::is_internal_type(
                                                                type_id,
                                                            );
                                                            if is_custom {
                                                                if type_resolver.is_xlang() && generics.len() > 0 {
                                                                    return Err(
                                                                        fory_core::error::Error::unsupported(
                                                                            "serialization of generic structs and enums is not supported in xlang mode",
                                                                        ),
                                                                    );
                                                                } else {
                                                                    generics = ::alloc::vec::Vec::new();
                                                                }
                                                            }
                                                            fory_core::meta::FieldType::new(type_id, true, generics)
                                                        },
                                                    ]),
                                                ) as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["last", "f1", "f2", "f3", "f5"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i64 = 0 as i64;
                let mut _f1: Option<Option<String>> = None;
                let mut _f2: Option<Option<String>> = None;
                let mut _f3: Option<Vec<Option<String>>> = None;
                let mut _f5: Option<Vec<Option<Vec<Option<String>>>>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Animal",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Animal",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Animal",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = Some(
                                        <Option<
                                            String,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f1 = Some(
                                        <Option<
                                            String,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Animal",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Animal",
                                    "f2",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = Some(
                                        <Option<
                                            String,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f2 = Some(
                                        <Option<
                                            String,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Animal",
                                    "f2",
                                    (&_f2) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            3i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Animal",
                                    "f3",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <Vec<
                                            Option<String>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <Vec<
                                            Option<String>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Animal",
                                    "f3",
                                    (&_f3) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            4i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Animal",
                                    "f5",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = Some(
                                        <Vec<
                                            Option<Vec<Option<String>>>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f5 = Some(
                                        <Vec<
                                            Option<Vec<Option<String>>>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Animal",
                                    "f5",
                                    (&_f5) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Animal",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Animal",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Option<
                                String,
                            > as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Option<
                                String,
                            > as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Vec<
                                Option<String>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f5: _f5
                            .unwrap_or_else(|| <Vec<
                                Option<Vec<Option<String>>>,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Animal {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 9u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<String> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<String> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<
                        Option<String>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<
                        Option<Vec<Option<String>>>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -768926692i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,19,0,1;f2,19,0,1;f3,20,0,0;f5,20,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Animal",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_varint64(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Animal",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Animal",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<String> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<String> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    String,
                > as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Animal",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Animal",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<String> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<String> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    String,
                > as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Animal",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Animal",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                <Vec<
                    Option<String>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f3,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Animal",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Animal",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                <Vec<
                    Option<Vec<Option<String>>>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f5,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Animal",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -768926692i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,19,0,1;f2,19,0,1;f3,20,0,0;f5,20,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Animal",
                    "last",
                    context,
                );
                let _last = context.reader.read_varint64()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Animal",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Animal",
                    "f1",
                    context,
                );
                let _f1 = <Option<
                    String,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Animal",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Animal",
                    "f2",
                    context,
                );
                let _f2 = <Option<
                    String,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Animal",
                    "f2",
                    (&_f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Animal",
                    "f3",
                    context,
                );
                let _f3 = <Vec<
                    Option<String>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Animal",
                    "f3",
                    (&_f3) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Animal",
                    "f5",
                    context,
                );
                let _f5 = <Vec<
                    Option<Vec<Option<String>>>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Animal",
                    "f5",
                    (&_f5) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                    f3: _f3,
                    f5: _f5,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Animal {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "Animal",
                    "f1",
                    &self.f1,
                    "f2",
                    &self.f2,
                    "f3",
                    &self.f3,
                    "f5",
                    &self.f5,
                    "last",
                    &&self.last,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Animal {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Animal {
            #[inline]
            fn eq(&self, other: &Animal) -> bool {
                self.last == other.last && self.f1 == other.f1 && self.f2 == other.f2
                    && self.f3 == other.f3 && self.f5 == other.f5
            }
        }
        let mut fory = Fory::default().compatible(true);
        fory.register::<Animal>(999).unwrap();
        let animal: Animal = Animal {
            f1: Some(String::from("f1")),
            f2: None,
            f3: <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    Option::<String>::None,
                    Some(String::from("f3")),
                ]),
            ),
            f5: <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    Some(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([Some(String::from("f1"))]),
                        ),
                    ),
                ]),
            ),
            last: 666,
        };
        let bin = fory.serialize(&animal).unwrap();
        let obj: Animal = fory.deserialize(&bin).unwrap();
        match (&animal, &obj) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::nullable"]
    #[doc(hidden)]
    pub const nullable: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::nullable"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 173usize,
            start_col: 4usize,
            end_line: 173usize,
            end_col: 12usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(nullable()),
        ),
    };
    fn nullable() {
        pub struct Item1 {
            f2: i8,
            f3: Option<i8>,
            f4: Option<i8>,
            f5: Option<i8>,
            f6: Option<i8>,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item1 {
            fn fory_default() -> Self {
                Self {
                    f2: <i8 as fory_core::ForyDefault>::fory_default(),
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f3: <Option<i8> as fory_core::ForyDefault>::fory_default(),
                    f4: <Option<i8> as fory_core::ForyDefault>::fory_default(),
                    f5: <Option<i8> as fory_core::ForyDefault>::fory_default(),
                    f6: <Option<i8> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                10u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f2", "last", "f3", "f4", "f5", "f6"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f2", "last", "f3", "f4", "f5", "f6"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f2: i8 = 0 as i8;
                let mut _last: i64 = 0 as i64;
                let mut _f3: Option<Option<i8>> = None;
                let mut _f4: Option<Option<i8>> = None;
                let mut _f5: Option<Option<i8>> = None;
                let mut _f6: Option<Option<i8>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f2 = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            3i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f4 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f4 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            4i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f5 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            5i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f6 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f6 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        f2: _f2,
                        last: _last,
                        f3: _f3
                            .unwrap_or_else(|| <Option<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f4: _f4
                            .unwrap_or_else(|| <Option<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f5: _f5
                            .unwrap_or_else(|| <Option<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Option<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 10u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -598292141i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f2,2,0,0;f3,2,0,1;f4,2,0,1;f5,2,0,1;f6,2,0,1;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_i8(self.f2);
                context.writer.write_varint64(self.last);
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f4,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f5,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -598292141i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f2,2,0,0;f3,2,0,1;f4,2,0,1;f5,2,0,1;f6,2,0,1;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f2 = context.reader.read_i8()?;
                let _last = context.reader.read_varint64()?;
                let _f3 = <Option<
                    i8,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f4 = <Option<
                    i8,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f5 = <Option<
                    i8,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f6 = <Option<
                    i8,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                Ok(Self {
                    f2: _f2,
                    last: _last,
                    f3: _f3,
                    f4: _f4,
                    f5: _f5,
                    f6: _f6,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &["f2", "f3", "f4", "f5", "f6", "last"];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f2,
                    &self.f3,
                    &self.f4,
                    &self.f5,
                    &self.f6,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Item1",
                    names,
                    values,
                )
            }
        }
        pub struct Item2 {
            f2: Option<i8>,
            f3: i8,
            f4: Option<i8>,
            f5: Option<i8>,
            f6: i8,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item2 {
            fn fory_default() -> Self {
                Self {
                    f3: <i8 as fory_core::ForyDefault>::fory_default(),
                    f6: <i8 as fory_core::ForyDefault>::fory_default(),
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f2: <Option<i8> as fory_core::ForyDefault>::fory_default(),
                    f4: <Option<i8> as fory_core::ForyDefault>::fory_default(),
                    f5: <Option<i8> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                11u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f3", "f6", "last", "f2", "f4", "f5"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f3", "f6", "last", "f2", "f4", "f5"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f3: i8 = 0 as i8;
                let mut _f6: i8 = 0 as i8;
                let mut _last: i64 = 0 as i64;
                let mut _f2: Option<Option<i8>> = None;
                let mut _f4: Option<Option<i8>> = None;
                let mut _f5: Option<Option<i8>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f3 = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f6 = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f6 = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            3i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f2 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            4i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f4 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f4 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            5i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f5 = Some(
                                        <Option<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        f3: _f3,
                        f6: _f6,
                        last: _last,
                        f2: _f2
                            .unwrap_or_else(|| <Option<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f4: _f4
                            .unwrap_or_else(|| <Option<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f5: _f5
                            .unwrap_or_else(|| <Option<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 11u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = 154854076i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f2,2,0,1;f3,2,0,0;f4,2,0,1;f5,2,0,1;f6,2,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_i8(self.f3);
                context.writer.write_i8(self.f6);
                context.writer.write_varint64(self.last);
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f4,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f5,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = 154854076i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f2,2,0,1;f3,2,0,0;f4,2,0,1;f5,2,0,1;f6,2,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f3 = context.reader.read_i8()?;
                let _f6 = context.reader.read_i8()?;
                let _last = context.reader.read_varint64()?;
                let _f2 = <Option<
                    i8,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f4 = <Option<
                    i8,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f5 = <Option<
                    i8,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                Ok(Self {
                    f3: _f3,
                    f6: _f6,
                    last: _last,
                    f2: _f2,
                    f4: _f4,
                    f5: _f5,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &["f2", "f3", "f4", "f5", "f6", "last"];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f2,
                    &self.f3,
                    &self.f4,
                    &self.f5,
                    &self.f6,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Item2",
                    names,
                    values,
                )
            }
        }
        let mut fory1 = Fory::default().compatible(true);
        let mut fory2 = Fory::default().compatible(true);
        fory1.register::<Item1>(999).unwrap();
        fory2.register::<Item2>(999).unwrap();
        let item1 = Item1 {
            f2: 43,
            f3: Some(44),
            f4: Some(45),
            f5: None,
            f6: None,
            last: 666,
        };
        let bin = fory1.serialize(&item1).unwrap();
        let item2: Item2 = fory2.deserialize(&bin).unwrap();
        match (&item2.f2.unwrap(), &item1.f2) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f3, &item1.f3.unwrap()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f4, &item1.f4) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f5, &item1.f5) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f6, &i8::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.last, &item1.last) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::nullable_container"]
    #[doc(hidden)]
    pub const nullable_container: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::nullable_container"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 227usize,
            start_col: 4usize,
            end_line: 227usize,
            end_col: 22usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(nullable_container()),
        ),
    };
    fn nullable_container() {
        pub struct Item1 {
            f1: Vec<i8>,
            f2: Option<Vec<i8>>,
            f3: HashSet<i8>,
            f4: Option<HashSet<i8>>,
            f5: HashMap<i8, Vec<i8>>,
            f6: Option<HashMap<i8, Vec<i8>>>,
            f7: Option<Vec<i8>>,
            f8: Option<HashSet<i8>>,
            f9: Option<HashMap<i8, i8>>,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item1 {
            fn fory_default() -> Self {
                Self {
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f1: <Vec<i8> as fory_core::ForyDefault>::fory_default(),
                    f2: <Option<Vec<i8>> as fory_core::ForyDefault>::fory_default(),
                    f7: <Option<Vec<i8>> as fory_core::ForyDefault>::fory_default(),
                    f3: <HashSet<i8> as fory_core::ForyDefault>::fory_default(),
                    f4: <Option<HashSet<i8>> as fory_core::ForyDefault>::fory_default(),
                    f8: <Option<HashSet<i8>> as fory_core::ForyDefault>::fory_default(),
                    f5: <HashMap<i8, Vec<i8>> as fory_core::ForyDefault>::fory_default(),
                    f6: <Option<
                        HashMap<i8, Vec<i8>>,
                    > as fory_core::ForyDefault>::fory_default(),
                    f9: <Option<
                        HashMap<i8, i8>,
                    > as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                12u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2", "f7", "f3", "f4", "f8", "f5", "f6", "f9"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = 42u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = 42u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f7",
                            {
                                let mut ft = {
                                    let mut type_id = 42u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <HashSet<
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <HashSet<
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f8",
                            {
                                let mut ft = {
                                    let mut type_id = <HashSet<
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        Vec<i8>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = 42u32;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        Vec<i8>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = 42u32;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f9",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &[
                    "last",
                    "f1",
                    "f2",
                    "f7",
                    "f3",
                    "f4",
                    "f8",
                    "f5",
                    "f6",
                    "f9",
                ];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i64 = 0 as i64;
                let mut _f1: Option<Vec<i8>> = None;
                let mut _f2: Option<Option<Vec<i8>>> = None;
                let mut _f7: Option<Option<Vec<i8>>> = None;
                let mut _f3: Option<HashSet<i8>> = None;
                let mut _f4: Option<Option<HashSet<i8>>> = None;
                let mut _f8: Option<Option<HashSet<i8>>> = None;
                let mut _f5: Option<HashMap<i8, Vec<i8>>> = None;
                let mut _f6: Option<Option<HashMap<i8, Vec<i8>>>> = None;
                let mut _f9: Option<Option<HashMap<i8, i8>>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = Some(
                                        <Vec<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f1 = Some(
                                        <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = Some(
                                        <Option<
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f2 = Some(
                                        <Option<
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            3i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f7 = Some(
                                        <Option<
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f7 = Some(
                                        <Option<
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            4i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <HashSet<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <HashSet<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            5i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f4 = Some(
                                        <Option<
                                            HashSet<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f4 = Some(
                                        <Option<
                                            HashSet<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            6i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f8 = Some(
                                        <Option<
                                            HashSet<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f8 = Some(
                                        <Option<
                                            HashSet<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            7i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = Some(
                                        <HashMap<
                                            i8,
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f5 = Some(
                                        <HashMap<
                                            i8,
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            8i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f6 = Some(
                                        <Option<
                                            HashMap<i8, Vec<i8>>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f6 = Some(
                                        <Option<
                                            HashMap<i8, Vec<i8>>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            9i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f9 = Some(
                                        <Option<
                                            HashMap<i8, i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f9 = Some(
                                        <Option<
                                            HashMap<i8, i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Vec<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Option<
                                Vec<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f7: _f7
                            .unwrap_or_else(|| <Option<
                                Vec<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <HashSet<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f4: _f4
                            .unwrap_or_else(|| <Option<
                                HashSet<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f8: _f8
                            .unwrap_or_else(|| <Option<
                                HashSet<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f5: _f5
                            .unwrap_or_else(|| <HashMap<
                                i8,
                                Vec<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Option<
                                HashMap<i8, Vec<i8>>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f9: _f9
                            .unwrap_or_else(|| <Option<
                                HashMap<i8, i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 12u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Vec<i8>> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Vec<i8>> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashSet<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<
                        HashSet<i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<
                        HashSet<i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashMap<
                        i8,
                        Vec<i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<
                        HashMap<i8, Vec<i8>>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<
                        HashMap<i8, i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -320037972i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,42,0,0;f2,42,0,1;f3,21,0,0;f4,21,0,1;f5,22,0,0;f6,22,0,1;f7,42,0,1;f8,21,0,1;f9,22,0,1;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_varint64(self.last);
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Vec<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Vec<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Vec<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Vec<i8>> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Vec<i8>> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Vec<i8>,
                > as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Vec<i8>> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Vec<i8>> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Vec<i8>,
                > as fory_core::Serializer>::fory_write(
                    &self.f7,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                <HashSet<
                    i8,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f3,
                    context,
                    true,
                )?;
                <Option<
                    HashSet<i8>,
                > as fory_core::Serializer>::fory_write(
                    &self.f4,
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                    true,
                )?;
                <Option<
                    HashSet<i8>,
                > as fory_core::Serializer>::fory_write(
                    &self.f8,
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                    true,
                )?;
                <HashMap<
                    i8,
                    Vec<i8>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f5,
                    context,
                    true,
                )?;
                <Option<
                    HashMap<i8, Vec<i8>>,
                > as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                    true,
                )?;
                <Option<
                    HashMap<i8, i8>,
                > as fory_core::Serializer>::fory_write(
                    &self.f9,
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                    true,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -320037972i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,42,0,0;f2,42,0,1;f3,21,0,0;f4,21,0,1;f5,22,0,0;f6,22,0,1;f7,42,0,1;f8,21,0,1;f9,22,0,1;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _last = context.reader.read_varint64()?;
                let _f1 = <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?;
                let _f2 = <Option<
                    Vec<i8>,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f7 = <Option<
                    Vec<i8>,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f3 = <HashSet<
                    i8,
                > as fory_core::Serializer>::fory_read_data(context)?;
                let _f4 = <Option<
                    HashSet<i8>,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f8 = <Option<
                    HashSet<i8>,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f5 = <HashMap<
                    i8,
                    Vec<i8>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                let _f6 = <Option<
                    HashMap<i8, Vec<i8>>,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f9 = <Option<
                    HashMap<i8, i8>,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                    f7: _f7,
                    f3: _f3,
                    f4: _f4,
                    f8: _f8,
                    f5: _f5,
                    f6: _f6,
                    f9: _f9,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "f1",
                    "f2",
                    "f3",
                    "f4",
                    "f5",
                    "f6",
                    "f7",
                    "f8",
                    "f9",
                    "last",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f2,
                    &self.f3,
                    &self.f4,
                    &self.f5,
                    &self.f6,
                    &self.f7,
                    &self.f8,
                    &self.f9,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Item1",
                    names,
                    values,
                )
            }
        }
        pub struct Item2 {
            f1: Option<Vec<i8>>,
            f2: Vec<i8>,
            f3: Option<HashSet<i8>>,
            f4: HashSet<i8>,
            f5: Option<HashMap<i8, Vec<i8>>>,
            f6: HashMap<i8, Vec<i8>>,
            f7: Vec<i8>,
            f8: HashSet<i8>,
            f9: HashMap<i8, i8>,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item2 {
            fn fory_default() -> Self {
                Self {
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f1: <Option<Vec<i8>> as fory_core::ForyDefault>::fory_default(),
                    f2: <Vec<i8> as fory_core::ForyDefault>::fory_default(),
                    f7: <Vec<i8> as fory_core::ForyDefault>::fory_default(),
                    f3: <Option<HashSet<i8>> as fory_core::ForyDefault>::fory_default(),
                    f4: <HashSet<i8> as fory_core::ForyDefault>::fory_default(),
                    f8: <HashSet<i8> as fory_core::ForyDefault>::fory_default(),
                    f5: <Option<
                        HashMap<i8, Vec<i8>>,
                    > as fory_core::ForyDefault>::fory_default(),
                    f6: <HashMap<i8, Vec<i8>> as fory_core::ForyDefault>::fory_default(),
                    f9: <HashMap<i8, i8> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                13u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2", "f7", "f3", "f4", "f8", "f5", "f6", "f9"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = 42u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = 42u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f7",
                            {
                                let mut ft = {
                                    let mut type_id = 42u32;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <HashSet<
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <HashSet<
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f8",
                            {
                                let mut ft = {
                                    let mut type_id = <HashSet<
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        Vec<i8>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = 42u32;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        Vec<i8>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = 42u32;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f9",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &[
                    "last",
                    "f1",
                    "f2",
                    "f7",
                    "f3",
                    "f4",
                    "f8",
                    "f5",
                    "f6",
                    "f9",
                ];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i64 = 0 as i64;
                let mut _f1: Option<Option<Vec<i8>>> = None;
                let mut _f2: Option<Vec<i8>> = None;
                let mut _f7: Option<Vec<i8>> = None;
                let mut _f3: Option<Option<HashSet<i8>>> = None;
                let mut _f4: Option<HashSet<i8>> = None;
                let mut _f8: Option<HashSet<i8>> = None;
                let mut _f5: Option<Option<HashMap<i8, Vec<i8>>>> = None;
                let mut _f6: Option<HashMap<i8, Vec<i8>>> = None;
                let mut _f9: Option<HashMap<i8, i8>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = Some(
                                        <Option<
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f1 = Some(
                                        <Option<
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = Some(
                                        <Vec<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f2 = Some(
                                        <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            3i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f7 = Some(
                                        <Vec<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f7 = Some(
                                        <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            4i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <Option<
                                            HashSet<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <Option<
                                            HashSet<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            5i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f4 = Some(
                                        <HashSet<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f4 = Some(
                                        <HashSet<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            6i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f8 = Some(
                                        <HashSet<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f8 = Some(
                                        <HashSet<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            7i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = Some(
                                        <Option<
                                            HashMap<i8, Vec<i8>>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f5 = Some(
                                        <Option<
                                            HashMap<i8, Vec<i8>>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            8i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f6 = Some(
                                        <HashMap<
                                            i8,
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f6 = Some(
                                        <HashMap<
                                            i8,
                                            Vec<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            9i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f9 = Some(
                                        <HashMap<
                                            i8,
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f9 = Some(
                                        <HashMap<
                                            i8,
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Option<
                                Vec<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Vec<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f7: _f7
                            .unwrap_or_else(|| <Vec<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Option<
                                HashSet<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f4: _f4
                            .unwrap_or_else(|| <HashSet<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f8: _f8
                            .unwrap_or_else(|| <HashSet<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f5: _f5
                            .unwrap_or_else(|| <Option<
                                HashMap<i8, Vec<i8>>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <HashMap<
                                i8,
                                Vec<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f9: _f9
                            .unwrap_or_else(|| <HashMap<
                                i8,
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 13u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Vec<i8>> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<
                        HashSet<i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashSet<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashSet<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<
                        HashMap<i8, Vec<i8>>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashMap<
                        i8,
                        Vec<i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashMap<i8, i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = 1066251850i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,42,0,1;f2,42,0,0;f3,21,0,1;f4,21,0,0;f5,22,0,1;f6,22,0,0;f7,42,0,0;f8,21,0,0;f9,22,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_varint64(self.last);
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Vec<i8>> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Vec<i8>> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Vec<i8>,
                > as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Vec<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Vec<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Vec<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Vec<i8> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Vec<i8> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Vec<
                    i8,
                > as fory_core::Serializer>::fory_write(
                    &self.f7,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                <Option<
                    HashSet<i8>,
                > as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                    true,
                )?;
                <HashSet<
                    i8,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f4,
                    context,
                    true,
                )?;
                <HashSet<
                    i8,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f8,
                    context,
                    true,
                )?;
                <Option<
                    HashMap<i8, Vec<i8>>,
                > as fory_core::Serializer>::fory_write(
                    &self.f5,
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                    true,
                )?;
                <HashMap<
                    i8,
                    Vec<i8>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f6,
                    context,
                    true,
                )?;
                <HashMap<
                    i8,
                    i8,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f9,
                    context,
                    true,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = 1066251850i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,42,0,1;f2,42,0,0;f3,21,0,1;f4,21,0,0;f5,22,0,1;f6,22,0,0;f7,42,0,0;f8,21,0,0;f9,22,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _last = context.reader.read_varint64()?;
                let _f1 = <Option<
                    Vec<i8>,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f2 = <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?;
                let _f7 = <Vec<i8> as fory_core::Serializer>::fory_read_data(context)?;
                let _f3 = <Option<
                    HashSet<i8>,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f4 = <HashSet<
                    i8,
                > as fory_core::Serializer>::fory_read_data(context)?;
                let _f8 = <HashSet<
                    i8,
                > as fory_core::Serializer>::fory_read_data(context)?;
                let _f5 = <Option<
                    HashMap<i8, Vec<i8>>,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f6 = <HashMap<
                    i8,
                    Vec<i8>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                let _f9 = <HashMap<
                    i8,
                    i8,
                > as fory_core::Serializer>::fory_read_data(context)?;
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                    f7: _f7,
                    f3: _f3,
                    f4: _f4,
                    f8: _f8,
                    f5: _f5,
                    f6: _f6,
                    f9: _f9,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "f1",
                    "f2",
                    "f3",
                    "f4",
                    "f5",
                    "f6",
                    "f7",
                    "f8",
                    "f9",
                    "last",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f2,
                    &self.f3,
                    &self.f4,
                    &self.f5,
                    &self.f6,
                    &self.f7,
                    &self.f8,
                    &self.f9,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Item2",
                    names,
                    values,
                )
            }
        }
        let mut fory1 = Fory::default().compatible(true);
        let mut fory2 = Fory::default().compatible(true);
        fory1.register::<Item1>(999).unwrap();
        fory2.register::<Item2>(999).unwrap();
        let item1 = Item1 {
            f1: <[_]>::into_vec(::alloc::boxed::box_new([44, 45])),
            f2: Some(<[_]>::into_vec(::alloc::boxed::box_new([43]))),
            f3: HashSet::from([44, 45]),
            f4: Some(HashSet::from([46, 47])),
            f5: HashMap::from([(48, <[_]>::into_vec(::alloc::boxed::box_new([49])))]),
            f6: Some(
                HashMap::from([(48, <[_]>::into_vec(::alloc::boxed::box_new([49])))]),
            ),
            f7: None,
            f8: None,
            f9: None,
            last: 666,
        };
        let bin = fory1.serialize(&item1).unwrap();
        let item2: Item2 = fory2.deserialize(&bin).unwrap();
        match (&item2.f1.unwrap(), &item1.f1) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f2, &item1.f2.unwrap()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f3.unwrap(), &item1.f3) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f4, &item1.f4.unwrap()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f5.unwrap(), &item1.f5) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f6, &item1.f6.unwrap()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f7, &Vec::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f8, &HashSet::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f9, &HashMap::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.last, &item1.last) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::inner_nullable"]
    #[doc(hidden)]
    pub const inner_nullable: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::inner_nullable"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 290usize,
            start_col: 4usize,
            end_line: 290usize,
            end_col: 18usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(inner_nullable()),
        ),
    };
    fn inner_nullable() {
        #[fory(debug)]
        pub struct Item1 {
            f1: Vec<Option<String>>,
            f2: HashSet<Option<i8>>,
            f3: HashMap<i8, Option<i8>>,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item1 {
            fn fory_default() -> Self {
                Self {
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f1: <Vec<Option<String>> as fory_core::ForyDefault>::fory_default(),
                    f2: <HashSet<Option<i8>> as fory_core::ForyDefault>::fory_default(),
                    f3: <HashMap<
                        i8,
                        Option<i8>,
                    > as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                14u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2", "f3"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <Vec<
                                        Option<String>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <HashSet<
                                        Option<i8>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        Option<i8>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["last", "f1", "f2", "f3"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i64 = 0 as i64;
                let mut _f1: Option<Vec<Option<String>>> = None;
                let mut _f2: Option<HashSet<Option<i8>>> = None;
                let mut _f3: Option<HashMap<i8, Option<i8>>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = Some(
                                        <Vec<
                                            Option<String>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f1 = Some(
                                        <Vec<
                                            Option<String>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f2",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = Some(
                                        <HashSet<
                                            Option<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f2 = Some(
                                        <HashSet<
                                            Option<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f2",
                                    (&_f2) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            3i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f3",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <HashMap<
                                            i8,
                                            Option<i8>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <HashMap<
                                            i8,
                                            Option<i8>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f3",
                                    (&_f3) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Vec<
                                Option<String>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <HashSet<
                                Option<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <HashMap<
                                i8,
                                Option<i8>,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 14u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<
                        Option<String>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashSet<
                        Option<i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashMap<
                        i8,
                        Option<i8>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -560543744i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,20,0,0;f2,21,0,0;f3,22,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_varint64(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                <Vec<
                    Option<String>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f1,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                <HashSet<
                    Option<i8>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f2,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                <HashMap<
                    i8,
                    Option<i8>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f3,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -560543744i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,20,0,0;f2,21,0,0;f3,22,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "last",
                    context,
                );
                let _last = context.reader.read_varint64()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f1",
                    context,
                );
                let _f1 = <Vec<
                    Option<String>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f2",
                    context,
                );
                let _f2 = <HashSet<
                    Option<i8>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f2",
                    (&_f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f3",
                    context,
                );
                let _f3 = <HashMap<
                    i8,
                    Option<i8>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f3",
                    (&_f3) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                    f3: _f3,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Item1",
                    "f1",
                    &self.f1,
                    "f2",
                    &self.f2,
                    "f3",
                    &self.f3,
                    "last",
                    &&self.last,
                )
            }
        }
        #[fory(debug)]
        pub struct Item2 {
            f1: Vec<String>,
            f2: HashSet<i8>,
            f3: HashMap<i8, i8>,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item2 {
            fn fory_default() -> Self {
                Self {
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f1: <Vec<String> as fory_core::ForyDefault>::fory_default(),
                    f2: <HashSet<i8> as fory_core::ForyDefault>::fory_default(),
                    f3: <HashMap<i8, i8> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                15u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2", "f3"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <Vec<
                                        String,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <HashSet<
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <HashMap<
                                        i8,
                                        i8,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                            {
                                                let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, false, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["last", "f1", "f2", "f3"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i64 = 0 as i64;
                let mut _f1: Option<Vec<String>> = None;
                let mut _f2: Option<HashSet<i8>> = None;
                let mut _f3: Option<HashMap<i8, i8>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = Some(
                                        <Vec<
                                            String,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f1 = Some(
                                        <Vec<
                                            String,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "f2",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = Some(
                                        <HashSet<
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f2 = Some(
                                        <HashSet<
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "f2",
                                    (&_f2) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            3i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "f3",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <HashMap<
                                            i8,
                                            i8,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <HashMap<
                                            i8,
                                            i8,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "f3",
                                    (&_f3) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Vec<
                                String,
                            > as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <HashSet<
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <HashMap<
                                i8,
                                i8,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 15u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<String> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashSet<i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <HashMap<i8, i8> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -560543744i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,20,0,0;f2,21,0,0;f3,22,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_varint64(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                <Vec<
                    String,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f1,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                <HashSet<
                    i8,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f2,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                <HashMap<
                    i8,
                    i8,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f3,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -560543744i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,20,0,0;f2,21,0,0;f3,22,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "last",
                    context,
                );
                let _last = context.reader.read_varint64()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "f1",
                    context,
                );
                let _f1 = <Vec<
                    String,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "f2",
                    context,
                );
                let _f2 = <HashSet<
                    i8,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "f2",
                    (&_f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "f3",
                    context,
                );
                let _f3 = <HashMap<
                    i8,
                    i8,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "f3",
                    (&_f3) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                    f3: _f3,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Item2",
                    "f1",
                    &self.f1,
                    "f2",
                    &self.f2,
                    "f3",
                    &self.f3,
                    "last",
                    &&self.last,
                )
            }
        }
        let mut fory1 = Fory::default().compatible(true);
        let mut fory2 = Fory::default().compatible(true);
        fory1.register::<Item1>(999).unwrap();
        fory2.register::<Item2>(999).unwrap();
        let item1 = Item1 {
            f1: <[_]>::into_vec(
                ::alloc::boxed::box_new([None, Some("hello".to_string())]),
            ),
            f2: HashSet::from([None, Some(43)]),
            f3: HashMap::from([(44, None), (45, Some(46))]),
            last: 666,
        };
        let bin = fory1.serialize(&item1).unwrap();
        let item2: Item2 = fory2.deserialize(&bin).unwrap();
        match (
            &item2.f1,
            &<[_]>::into_vec(
                ::alloc::boxed::box_new([String::default(), "hello".to_string()]),
            ),
        ) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f2, &HashSet::from([0, 43])) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f3, &HashMap::from([(44, 0), (45, 46)])) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.last, &item1.last) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::nullable_struct"]
    #[doc(hidden)]
    pub const nullable_struct: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::nullable_struct"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 329usize,
            start_col: 4usize,
            end_line: 329usize,
            end_col: 19usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(nullable_struct()),
        ),
    };
    fn nullable_struct() {
        #[fory(debug)]
        pub struct Item {
            name: String,
            data: Vec<Option<String>>,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item {
            fn fory_default() -> Self {
                Self {
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    name: <String as fory_core::ForyDefault>::fory_default(),
                    data: <Vec<Option<String>> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                16u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "name", "data"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "name",
                            {
                                let mut ft = {
                                    let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "data",
                            {
                                let mut ft = {
                                    let mut type_id = <Vec<
                                        Option<String>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <String as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["last", "name", "data"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i64 = 0 as i64;
                let mut _name: Option<String> = None;
                let mut _data: Option<Vec<Option<String>>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item",
                                    "name",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _name = Some(
                                        <String as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _name = Some(
                                        <String as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item",
                                    "name",
                                    (&_name) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item",
                                    "data",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _data = Some(
                                        <Vec<
                                            Option<String>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _data = Some(
                                        <Vec<
                                            Option<String>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item",
                                    "data",
                                    (&_data) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        name: _name
                            .unwrap_or_else(|| <String as fory_core::ForyDefault>::fory_default()),
                        data: _data
                            .unwrap_or_else(|| <Vec<
                                Option<String>,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 16u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <String as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<
                        Option<String>,
                    > as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -1704078581i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "data,20,0,0;last,7,0,0;name,19,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_varint64(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item",
                    "name",
                    (&self.name) as &dyn std::any::Any,
                    context,
                );
                <String as fory_core::Serializer>::fory_write_data(&self.name, context)?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item",
                    "name",
                    (&self.name) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item",
                    "data",
                    (&self.data) as &dyn std::any::Any,
                    context,
                );
                <Vec<
                    Option<String>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.data,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item",
                    "data",
                    (&self.data) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -1704078581i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "data,20,0,0;last,7,0,0;name,19,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item",
                    "last",
                    context,
                );
                let _last = context.reader.read_varint64()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item",
                    "name",
                    context,
                );
                let _name = <String as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item",
                    "name",
                    (&_name) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item",
                    "data",
                    context,
                );
                let _data = <Vec<
                    Option<String>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item",
                    "data",
                    (&_data) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    name: _name,
                    data: _data,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Item",
                    "name",
                    &self.name,
                    "data",
                    &self.data,
                    "last",
                    &&self.last,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Item {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Item {
            #[inline]
            fn eq(&self, other: &Item) -> bool {
                self.last == other.last && self.name == other.name
                    && self.data == other.data
            }
        }
        #[fory(debug)]
        pub struct Person1 {
            f1: Item,
            f2: Option<Item>,
            f3: Option<Item>,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Person1 {
            fn fory_default() -> Self {
                Self {
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f1: <Item as fory_core::ForyDefault>::fory_default(),
                    f2: <Option<Item> as fory_core::ForyDefault>::fory_default(),
                    f3: <Option<Item> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Person1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                17u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2", "f3"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <Item as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <Item as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <Item as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["last", "f1", "f2", "f3"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i64 = 0 as i64;
                let mut _f1: Option<Item> = None;
                let mut _f2: Option<Option<Item>> = None;
                let mut _f3: Option<Option<Item>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Item as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f1 = Some(
                                    <Item as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f2",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Item,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f2 = Some(
                                    <Option<
                                        Item,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f2",
                                    (&_f2) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            3i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f3",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Item,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f3 = Some(
                                    <Option<
                                        Item,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f3",
                                    (&_f3) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Item as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Option<
                                Item,
                            > as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Option<
                                Item,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Person1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 17u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Item as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Item> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Item> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -1402128952i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,1;f3,0,0,1;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_varint64(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Item as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Item> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Item> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Item,
                > as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Item> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Item> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Item,
                > as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -1402128952i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,1;f3,0,0,1;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "last",
                    context,
                );
                let _last = context.reader.read_varint64()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f1",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f1 = <Item as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f2",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Item> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Item> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f2 = <Option<
                    Item,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f2",
                    (&_f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f3",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Item> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Item> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f3 = <Option<
                    Item,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f3",
                    (&_f3) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                    f3: _f3,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Person1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Person1",
                    "f1",
                    &self.f1,
                    "f2",
                    &self.f2,
                    "f3",
                    &self.f3,
                    "last",
                    &&self.last,
                )
            }
        }
        #[fory(debug)]
        pub struct Person2 {
            f1: Option<Item>,
            f2: Item,
            f3: Item,
            last: i64,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Person2 {
            fn fory_default() -> Self {
                Self {
                    last: <i64 as fory_core::ForyDefault>::fory_default(),
                    f1: <Option<Item> as fory_core::ForyDefault>::fory_default(),
                    f2: <Item as fory_core::ForyDefault>::fory_default(),
                    f3: <Item as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Person2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                18u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2", "f3"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i64 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <Item as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <Item as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <Item as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["last", "f1", "f2", "f3"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i64 = 0 as i64;
                let mut _f1: Option<Option<Item>> = None;
                let mut _f2: Option<Item> = None;
                let mut _f3: Option<Item> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i64 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i64 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Item,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f1 = Some(
                                    <Option<
                                        Item,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f2",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Item as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f2 = Some(
                                    <Item as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f2",
                                    (&_f2) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            3i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f3",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Item as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f3 = Some(
                                    <Item as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f3",
                                    (&_f3) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Option<
                                Item,
                            > as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Item as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Item as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Person2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 18u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i64 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Item> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Item as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Item as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -934415961i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,1;f2,0,0,0;f3,0,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_varint64(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Item> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Item> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Item,
                > as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Item as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Item as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -934415961i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,1;f2,0,0,0;f3,0,0,0;last,7,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "last",
                    context,
                );
                let _last = context.reader.read_varint64()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f1",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Item> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Item> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f1 = <Option<
                    Item,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f2",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f2 = <Item as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f2",
                    (&_f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f3",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Item as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Item as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f3 = <Item as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f3",
                    (&_f3) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                    f3: _f3,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Person2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Person2",
                    "f1",
                    &self.f1,
                    "f2",
                    &self.f2,
                    "f3",
                    &self.f3,
                    "last",
                    &&self.last,
                )
            }
        }
        let mut fory1 = Fory::default().compatible(true);
        let mut fory2 = Fory::default().compatible(true);
        fory1.register::<Item>(199).unwrap();
        fory1.register::<Person1>(200).unwrap();
        fory2.register::<Item>(199).unwrap();
        fory2.register::<Person2>(200).unwrap();
        let person1 = Person1 {
            f1: Item {
                name: "f1".to_string(),
                data: <[_]>::into_vec(
                    ::alloc::boxed::box_new([None, Some("hi".to_string())]),
                ),
                last: 43,
            },
            f2: None,
            f3: Some(Item {
                name: "b".to_string(),
                data: <[_]>::into_vec(
                    ::alloc::boxed::box_new([None, Some("a".to_string())]),
                ),
                last: 45,
            }),
            last: 46,
        };
        let bin = fory1.serialize(&person1).unwrap();
        let person2: Person2 = fory2.deserialize(&bin).unwrap();
        match (&person2.f1.unwrap(), &person1.f1) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        use fory_core::ForyDefault;
        match (&person2.f2, &Item::fory_default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&person2.f3, &person1.f3.unwrap()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&person2.last, &person1.last) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::enum_without_payload"]
    #[doc(hidden)]
    pub const enum_without_payload: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::enum_without_payload"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 387usize,
            start_col: 4usize,
            end_line: 387usize,
            end_col: 24usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(enum_without_payload()),
        ),
    };
    fn enum_without_payload() {
        enum Color1 {
            #[default]
            Green,
            Red,
            Blue,
            White,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Color1 {
            fn fory_default() -> Self {
                Self::default()
            }
        }
        impl fory_core::StructSerializer for Color1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                19u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                let _ = xlang;
                fory_core::serializer::enum_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &[]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                Ok(Vec::new())
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (
                                "Green".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                            (
                                "Red".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                            (
                                "Blue".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                            (
                                "White".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                        ]),
                    ),
                )
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                Err(
                    fory_core::Error::not_allowed(
                        "`fory_read_compatible` should only be invoked at struct type",
                    ),
                )
            }
        }
        impl fory_core::Serializer for Color1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 19u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::ENUM
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                4
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::enum_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_xlang() {
                    match self {
                        Self::Green => {
                            context.writer.write_var_uint32(0u32);
                        }
                        Self::Red => {
                            context.writer.write_var_uint32(1u32);
                        }
                        Self::Blue => {
                            context.writer.write_var_uint32(2u32);
                        }
                        Self::White => {
                            context.writer.write_var_uint32(3u32);
                        }
                    }
                    Ok(())
                } else {
                    if context.is_compatible() {
                        match self {
                            Self::Green => {
                                context.writer.write_var_uint32((0u32 << 2) | 0b0);
                            }
                            Self::Red => {
                                context.writer.write_var_uint32((1u32 << 2) | 0b0);
                            }
                            Self::Blue => {
                                context.writer.write_var_uint32((2u32 << 2) | 0b0);
                            }
                            Self::White => {
                                context.writer.write_var_uint32((3u32 << 2) | 0b0);
                            }
                        }
                        Ok(())
                    } else {
                        match self {
                            Self::Green => {
                                context.writer.write_var_uint32(0u32);
                            }
                            Self::Red => {
                                context.writer.write_var_uint32(1u32);
                            }
                            Self::Blue => {
                                context.writer.write_var_uint32(2u32);
                            }
                            Self::White => {
                                context.writer.write_var_uint32(3u32);
                            }
                        }
                        Ok(())
                    }
                }
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::enum_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                fory_core::serializer::enum_::read::<
                    Self,
                >(context, ref_mode, read_type_info)
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                fory_core::serializer::enum_::read::<Self>(context, ref_mode, false)
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_xlang() {
                    let ordinal = context.reader.read_varuint32()?;
                    match ordinal {
                        0u32 => Ok(Self::Green),
                        1u32 => Ok(Self::Red),
                        2u32 => Ok(Self::Blue),
                        3u32 => Ok(Self::White),
                        _ => {
                            if context.is_compatible() {
                                Ok(Self::Green)
                            } else {
                                return Err(
                                    fory_core::error::Error::unknown_enum("unknown enum value"),
                                );
                            }
                        }
                    }
                } else {
                    if context.is_compatible() {
                        let encoded_tag = context.reader.read_varuint32()?;
                        let tag = encoded_tag >> 2;
                        let variant_type = encoded_tag & 0b11;
                        match tag {
                            0u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::Green);
                                }
                                Ok(Self::Green)
                            }
                            1u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::Red);
                                }
                                Ok(Self::Red)
                            }
                            2u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::Blue);
                                }
                                Ok(Self::Blue)
                            }
                            3u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::White);
                                }
                                Ok(Self::White)
                            }
                            _ => {
                                use fory_core::serializer::skip::skip_enum_variant;
                                skip_enum_variant(context, variant_type, &None)?;
                                Ok(Self::Green)
                            }
                        }
                    } else {
                        let tag = context.reader.read_varuint32()?;
                        match tag {
                            0u32 => Ok(Self::Green),
                            1u32 => Ok(Self::Red),
                            2u32 => Ok(Self::Blue),
                            3u32 => Ok(Self::White),
                            _ => {
                                return Err(
                                    fory_core::error::Error::unknown_enum("unknown enum value"),
                                );
                            }
                        }
                    }
                }
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::enum_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Color1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Color1::Green => "Green",
                        Color1::Red => "Red",
                        Color1::Blue => "Blue",
                        Color1::White => "White",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Color1 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Color1 {
            #[inline]
            fn eq(&self, other: &Color1) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Color1 {
            #[inline]
            fn default() -> Color1 {
                Self::Green
            }
        }
        enum Color2 {
            #[default]
            Green,
            Red,
            Blue,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Color2 {
            fn fory_default() -> Self {
                Self::default()
            }
        }
        impl fory_core::StructSerializer for Color2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                20u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                let _ = xlang;
                fory_core::serializer::enum_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &[]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                Ok(Vec::new())
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (
                                "Green".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                            (
                                "Red".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                            (
                                "Blue".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                        ]),
                    ),
                )
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                Err(
                    fory_core::Error::not_allowed(
                        "`fory_read_compatible` should only be invoked at struct type",
                    ),
                )
            }
        }
        impl fory_core::Serializer for Color2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 20u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::ENUM
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                4
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::enum_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_xlang() {
                    match self {
                        Self::Green => {
                            context.writer.write_var_uint32(0u32);
                        }
                        Self::Red => {
                            context.writer.write_var_uint32(1u32);
                        }
                        Self::Blue => {
                            context.writer.write_var_uint32(2u32);
                        }
                    }
                    Ok(())
                } else {
                    if context.is_compatible() {
                        match self {
                            Self::Green => {
                                context.writer.write_var_uint32((0u32 << 2) | 0b0);
                            }
                            Self::Red => {
                                context.writer.write_var_uint32((1u32 << 2) | 0b0);
                            }
                            Self::Blue => {
                                context.writer.write_var_uint32((2u32 << 2) | 0b0);
                            }
                        }
                        Ok(())
                    } else {
                        match self {
                            Self::Green => {
                                context.writer.write_var_uint32(0u32);
                            }
                            Self::Red => {
                                context.writer.write_var_uint32(1u32);
                            }
                            Self::Blue => {
                                context.writer.write_var_uint32(2u32);
                            }
                        }
                        Ok(())
                    }
                }
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::enum_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                fory_core::serializer::enum_::read::<
                    Self,
                >(context, ref_mode, read_type_info)
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                fory_core::serializer::enum_::read::<Self>(context, ref_mode, false)
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_xlang() {
                    let ordinal = context.reader.read_varuint32()?;
                    match ordinal {
                        0u32 => Ok(Self::Green),
                        1u32 => Ok(Self::Red),
                        2u32 => Ok(Self::Blue),
                        _ => {
                            if context.is_compatible() {
                                Ok(Self::Green)
                            } else {
                                return Err(
                                    fory_core::error::Error::unknown_enum("unknown enum value"),
                                );
                            }
                        }
                    }
                } else {
                    if context.is_compatible() {
                        let encoded_tag = context.reader.read_varuint32()?;
                        let tag = encoded_tag >> 2;
                        let variant_type = encoded_tag & 0b11;
                        match tag {
                            0u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::Green);
                                }
                                Ok(Self::Green)
                            }
                            1u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::Red);
                                }
                                Ok(Self::Red)
                            }
                            2u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::Blue);
                                }
                                Ok(Self::Blue)
                            }
                            _ => {
                                use fory_core::serializer::skip::skip_enum_variant;
                                skip_enum_variant(context, variant_type, &None)?;
                                Ok(Self::Green)
                            }
                        }
                    } else {
                        let tag = context.reader.read_varuint32()?;
                        match tag {
                            0u32 => Ok(Self::Green),
                            1u32 => Ok(Self::Red),
                            2u32 => Ok(Self::Blue),
                            _ => {
                                return Err(
                                    fory_core::error::Error::unknown_enum("unknown enum value"),
                                );
                            }
                        }
                    }
                }
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::enum_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Color2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Color2::Green => "Green",
                        Color2::Red => "Red",
                        Color2::Blue => "Blue",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Color2 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Color2 {
            #[inline]
            fn eq(&self, other: &Color2) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Color2 {
            #[inline]
            fn default() -> Color2 {
                Self::Green
            }
        }
        #[fory(debug)]
        struct Person1 {
            f1: Color1,
            f2: Color1,
            f3: Color2,
            f5: Vec<Color1>,
            f6: Option<Color1>,
            f7: Option<Color1>,
            f8: Color1,
            last: i8,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Person1 {
            fn fory_default() -> Self {
                Self {
                    last: <i8 as fory_core::ForyDefault>::fory_default(),
                    f5: <Vec<Color1> as fory_core::ForyDefault>::fory_default(),
                    f1: <Color1 as fory_core::ForyDefault>::fory_default(),
                    f2: <Color1 as fory_core::ForyDefault>::fory_default(),
                    f3: <Color2 as fory_core::ForyDefault>::fory_default(),
                    f6: <Option<Color1> as fory_core::ForyDefault>::fory_default(),
                    f7: <Option<Color1> as fory_core::ForyDefault>::fory_default(),
                    f8: <Color1 as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Person1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                21u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f5", "f1", "f2", "f3", "f6", "f7", "f8"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <Vec<
                                        Color1,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <Color2 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f7",
                            {
                                let mut ft = {
                                    let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f8",
                            {
                                let mut ft = {
                                    let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &[
                    "last",
                    "f5",
                    "f1",
                    "f2",
                    "f3",
                    "f6",
                    "f7",
                    "f8",
                ];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i8 = 0 as i8;
                let mut _f5: Option<Vec<Color1>> = None;
                let mut _f1: Option<Color1> = None;
                let mut _f2: Option<Color1> = None;
                let mut _f3: Option<Color2> = None;
                let mut _f6: Option<Option<Color1>> = None;
                let mut _f7: Option<Option<Color1>> = None;
                let mut _f8: Option<Color1> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f5",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = Some(
                                        <Vec<
                                            Color1,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f5 = Some(
                                        <Vec<
                                            Color1,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f5",
                                    (&_f5) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color1 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f1 = Some(
                                    <Color1 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            3i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f2",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color1 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f2 = Some(
                                    <Color1 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f2",
                                    (&_f2) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            4i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f3",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color2 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f3 = Some(
                                    <Color2 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f3",
                                    (&_f3) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            5i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f6",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color1,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f6 = Some(
                                    <Option<
                                        Color1,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f6",
                                    (&_f6) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            6i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f7",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color1,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f7 = Some(
                                    <Option<
                                        Color1,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f7",
                                    (&_f7) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            7i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    "f8",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color1 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f8 = Some(
                                    <Color1 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    "f8",
                                    (&_f8) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person1",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person1",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f5: _f5
                            .unwrap_or_else(|| <Vec<
                                Color1,
                            > as fory_core::ForyDefault>::fory_default()),
                        f1: _f1
                            .unwrap_or_else(|| <Color1 as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Color1 as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Color2 as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Option<
                                Color1,
                            > as fory_core::ForyDefault>::fory_default()),
                        f7: _f7
                            .unwrap_or_else(|| <Option<
                                Color1,
                            > as fory_core::ForyDefault>::fory_default()),
                        f8: _f8
                            .unwrap_or_else(|| <Color1 as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Person1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 21u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<Color1> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color1 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color1 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color2 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color1> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color1> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color1 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -261160600i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,0;f3,0,0,0;f5,20,0,0;f6,0,0,1;f7,0,0,1;f8,0,0,0;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_i8(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                <Vec<
                    Color1,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f5,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color1 as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color1 as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color2 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color2 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color2 as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f6",
                    (&self.f6) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color1> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color1> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color1,
                > as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f6",
                    (&self.f6) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f7",
                    (&self.f7) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color1> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color1> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color1,
                > as fory_core::Serializer>::fory_write(
                    &self.f7,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f7",
                    (&self.f7) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person1",
                    "f8",
                    (&self.f8) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color1 as fory_core::Serializer>::fory_write(
                    &self.f8,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person1",
                    "f8",
                    (&self.f8) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -261160600i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,0;f3,0,0,0;f5,20,0,0;f6,0,0,1;f7,0,0,1;f8,0,0,0;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "last",
                    context,
                );
                let _last = context.reader.read_i8()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f5",
                    context,
                );
                let _f5 = <Vec<
                    Color1,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f5",
                    (&_f5) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f1",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f1 = <Color1 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f2",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f2 = <Color1 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f2",
                    (&_f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f3",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color2 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color2 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f3 = <Color2 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f3",
                    (&_f3) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f6",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color1> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color1> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f6 = <Option<
                    Color1,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f6",
                    (&_f6) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f7",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color1> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color1> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f7 = <Option<
                    Color1,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f7",
                    (&_f7) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person1",
                    "f8",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f8 = <Color1 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person1",
                    "f8",
                    (&_f8) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    f5: _f5,
                    f1: _f1,
                    f2: _f2,
                    f3: _f3,
                    f6: _f6,
                    f7: _f7,
                    f8: _f8,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Person1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "f1",
                    "f2",
                    "f3",
                    "f5",
                    "f6",
                    "f7",
                    "f8",
                    "last",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f2,
                    &self.f3,
                    &self.f5,
                    &self.f6,
                    &self.f7,
                    &self.f8,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Person1",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Person1 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Person1 {
            #[inline]
            fn eq(&self, other: &Person1) -> bool {
                self.last == other.last && self.f1 == other.f1 && self.f2 == other.f2
                    && self.f3 == other.f3 && self.f5 == other.f5 && self.f6 == other.f6
                    && self.f7 == other.f7 && self.f8 == other.f8
            }
        }
        #[fory(debug)]
        struct Person2 {
            f1: Color1,
            f2: Color2,
            f4: Color2,
            f5: Vec<Color2>,
            f6: Color1,
            f7: Color1,
            f8: Option<Color1>,
            last: i8,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Person2 {
            fn fory_default() -> Self {
                Self {
                    last: <i8 as fory_core::ForyDefault>::fory_default(),
                    f5: <Vec<Color2> as fory_core::ForyDefault>::fory_default(),
                    f1: <Color1 as fory_core::ForyDefault>::fory_default(),
                    f2: <Color2 as fory_core::ForyDefault>::fory_default(),
                    f4: <Color2 as fory_core::ForyDefault>::fory_default(),
                    f6: <Color1 as fory_core::ForyDefault>::fory_default(),
                    f7: <Color1 as fory_core::ForyDefault>::fory_default(),
                    f8: <Option<Color1> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Person2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                22u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f5", "f1", "f2", "f4", "f6", "f7", "f8"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <Vec<
                                        Color2,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <Color2 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = ::alloc::vec::Vec::new()
                                                    as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <Color2 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <Color2 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f7",
                            {
                                let mut ft = {
                                    let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f8",
                            {
                                let mut ft = {
                                    let mut type_id = <Color1 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &[
                    "last",
                    "f5",
                    "f1",
                    "f2",
                    "f4",
                    "f6",
                    "f7",
                    "f8",
                ];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i8 = 0 as i8;
                let mut _f5: Option<Vec<Color2>> = None;
                let mut _f1: Option<Color1> = None;
                let mut _f2: Option<Color2> = None;
                let mut _f4: Option<Color2> = None;
                let mut _f6: Option<Color1> = None;
                let mut _f7: Option<Color1> = None;
                let mut _f8: Option<Option<Color1>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f5",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = Some(
                                        <Vec<
                                            Color2,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f5 = Some(
                                        <Vec<
                                            Color2,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f5",
                                    (&_f5) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color1 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f1 = Some(
                                    <Color1 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            3i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f2",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color2 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f2 = Some(
                                    <Color2 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f2",
                                    (&_f2) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            4i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f4",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color2 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f4 = Some(
                                    <Color2 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f4",
                                    (&_f4) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            5i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f6",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color1 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f6 = Some(
                                    <Color1 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f6",
                                    (&_f6) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            6i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f7",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color1 as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f7 = Some(
                                    <Color1 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f7",
                                    (&_f7) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            7i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    "f8",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color1,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f8 = Some(
                                    <Option<
                                        Color1,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    "f8",
                                    (&_f8) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Person2",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Person2",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f5: _f5
                            .unwrap_or_else(|| <Vec<
                                Color2,
                            > as fory_core::ForyDefault>::fory_default()),
                        f1: _f1
                            .unwrap_or_else(|| <Color1 as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Color2 as fory_core::ForyDefault>::fory_default()),
                        f4: _f4
                            .unwrap_or_else(|| <Color2 as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Color1 as fory_core::ForyDefault>::fory_default()),
                        f7: _f7
                            .unwrap_or_else(|| <Color1 as fory_core::ForyDefault>::fory_default()),
                        f8: _f8
                            .unwrap_or_else(|| <Option<
                                Color1,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Person2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 22u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<Color2> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color1 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color2 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color2 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color1 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color1 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color1> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -1258340730i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,0;f4,0,0,0;f5,20,0,0;f6,0,0,0;f7,0,0,0;f8,0,0,1;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_i8(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                <Vec<
                    Color2,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.f5,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color1 as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color2 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color2 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color2 as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f4",
                    (&self.f4) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color2 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color2 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color2 as fory_core::Serializer>::fory_write(
                    &self.f4,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f4",
                    (&self.f4) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f6",
                    (&self.f6) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color1 as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f6",
                    (&self.f6) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f7",
                    (&self.f7) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color1 as fory_core::Serializer>::fory_write(
                    &self.f7,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f7",
                    (&self.f7) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Person2",
                    "f8",
                    (&self.f8) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color1> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color1> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color1,
                > as fory_core::Serializer>::fory_write(
                    &self.f8,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Person2",
                    "f8",
                    (&self.f8) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -1258340730i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,0;f4,0,0,0;f5,20,0,0;f6,0,0,0;f7,0,0,0;f8,0,0,1;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "last",
                    context,
                );
                let _last = context.reader.read_i8()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f5",
                    context,
                );
                let _f5 = <Vec<
                    Color2,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f5",
                    (&_f5) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f1",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f1 = <Color1 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f2",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color2 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color2 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f2 = <Color2 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f2",
                    (&_f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f4",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color2 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color2 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f4 = <Color2 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f4",
                    (&_f4) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f6",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f6 = <Color1 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f6",
                    (&_f6) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f7",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color1 as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color1 as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f7 = <Color1 as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f7",
                    (&_f7) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Person2",
                    "f8",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color1> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color1> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f8 = <Option<
                    Color1,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Person2",
                    "f8",
                    (&_f8) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    f5: _f5,
                    f1: _f1,
                    f2: _f2,
                    f4: _f4,
                    f6: _f6,
                    f7: _f7,
                    f8: _f8,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Person2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "f1",
                    "f2",
                    "f4",
                    "f5",
                    "f6",
                    "f7",
                    "f8",
                    "last",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f2,
                    &self.f4,
                    &self.f5,
                    &self.f6,
                    &self.f7,
                    &self.f8,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Person2",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Person2 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Person2 {
            #[inline]
            fn eq(&self, other: &Person2) -> bool {
                self.last == other.last && self.f1 == other.f1 && self.f2 == other.f2
                    && self.f4 == other.f4 && self.f5 == other.f5 && self.f6 == other.f6
                    && self.f7 == other.f7 && self.f8 == other.f8
            }
        }
        let mut fory1 = Fory::default().compatible(true).xlang(true);
        fory1.register::<Color1>(101).unwrap();
        fory1.register::<Color2>(102).unwrap();
        fory1.register::<Person1>(103).unwrap();
        let mut fory2 = Fory::default().compatible(true).xlang(true);
        fory2.register::<Color1>(101).unwrap();
        fory2.register::<Color2>(102).unwrap();
        fory2.register::<Person2>(103).unwrap();
        let person1 = Person1 {
            f1: Color1::Blue,
            f2: Color1::White,
            f3: Color2::Green,
            f5: <[_]>::into_vec(::alloc::boxed::box_new([Color1::Blue])),
            f6: Some(Color1::Blue),
            f7: None,
            f8: Color1::Red,
            last: 10,
        };
        let bin = fory1.serialize(&person1).unwrap();
        let person2: Person2 = fory2.deserialize(&bin).expect("");
        match (&person2.f1, &person1.f1) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&person2.f2, &Color2::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&person2.f4, &Color2::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&person2.f6, &person1.f6.unwrap()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&person2.f7, &Color1::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&person2.f8.unwrap(), &person1.f8) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&person2.last, &person1.last) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::named_enum"]
    #[doc(hidden)]
    pub const named_enum: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::named_enum"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 463usize,
            start_col: 4usize,
            end_line: 463usize,
            end_col: 14usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(named_enum()),
        ),
    };
    fn named_enum() {
        enum Color {
            #[default]
            Green,
            Red,
            Blue,
            White,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Color {
            fn fory_default() -> Self {
                Self::default()
            }
        }
        impl fory_core::StructSerializer for Color {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                23u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                let _ = xlang;
                fory_core::serializer::enum_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &[]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                Ok(Vec::new())
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (
                                "Green".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                            (
                                "Red".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                            (
                                "Blue".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                            (
                                "White".to_string(),
                                std::any::TypeId::of::<()>(),
                                Vec::new(),
                            ),
                        ]),
                    ),
                )
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                Err(
                    fory_core::Error::not_allowed(
                        "`fory_read_compatible` should only be invoked at struct type",
                    ),
                )
            }
        }
        impl fory_core::Serializer for Color {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 23u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::ENUM
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                4
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::enum_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_xlang() {
                    match self {
                        Self::Green => {
                            context.writer.write_var_uint32(0u32);
                        }
                        Self::Red => {
                            context.writer.write_var_uint32(1u32);
                        }
                        Self::Blue => {
                            context.writer.write_var_uint32(2u32);
                        }
                        Self::White => {
                            context.writer.write_var_uint32(3u32);
                        }
                    }
                    Ok(())
                } else {
                    if context.is_compatible() {
                        match self {
                            Self::Green => {
                                context.writer.write_var_uint32((0u32 << 2) | 0b0);
                            }
                            Self::Red => {
                                context.writer.write_var_uint32((1u32 << 2) | 0b0);
                            }
                            Self::Blue => {
                                context.writer.write_var_uint32((2u32 << 2) | 0b0);
                            }
                            Self::White => {
                                context.writer.write_var_uint32((3u32 << 2) | 0b0);
                            }
                        }
                        Ok(())
                    } else {
                        match self {
                            Self::Green => {
                                context.writer.write_var_uint32(0u32);
                            }
                            Self::Red => {
                                context.writer.write_var_uint32(1u32);
                            }
                            Self::Blue => {
                                context.writer.write_var_uint32(2u32);
                            }
                            Self::White => {
                                context.writer.write_var_uint32(3u32);
                            }
                        }
                        Ok(())
                    }
                }
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::enum_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                fory_core::serializer::enum_::read::<
                    Self,
                >(context, ref_mode, read_type_info)
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                fory_core::serializer::enum_::read::<Self>(context, ref_mode, false)
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_xlang() {
                    let ordinal = context.reader.read_varuint32()?;
                    match ordinal {
                        0u32 => Ok(Self::Green),
                        1u32 => Ok(Self::Red),
                        2u32 => Ok(Self::Blue),
                        3u32 => Ok(Self::White),
                        _ => {
                            if context.is_compatible() {
                                Ok(Self::Green)
                            } else {
                                return Err(
                                    fory_core::error::Error::unknown_enum("unknown enum value"),
                                );
                            }
                        }
                    }
                } else {
                    if context.is_compatible() {
                        let encoded_tag = context.reader.read_varuint32()?;
                        let tag = encoded_tag >> 2;
                        let variant_type = encoded_tag & 0b11;
                        match tag {
                            0u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::Green);
                                }
                                Ok(Self::Green)
                            }
                            1u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::Red);
                                }
                                Ok(Self::Red)
                            }
                            2u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::Blue);
                                }
                                Ok(Self::Blue)
                            }
                            3u32 => {
                                if variant_type != 0b0 {
                                    use fory_core::serializer::skip::skip_enum_variant;
                                    skip_enum_variant(context, variant_type, &None)?;
                                    return Ok(Self::White);
                                }
                                Ok(Self::White)
                            }
                            _ => {
                                use fory_core::serializer::skip::skip_enum_variant;
                                skip_enum_variant(context, variant_type, &None)?;
                                Ok(Self::Green)
                            }
                        }
                    } else {
                        let tag = context.reader.read_varuint32()?;
                        match tag {
                            0u32 => Ok(Self::Green),
                            1u32 => Ok(Self::Red),
                            2u32 => Ok(Self::Blue),
                            3u32 => Ok(Self::White),
                            _ => {
                                return Err(
                                    fory_core::error::Error::unknown_enum("unknown enum value"),
                                );
                            }
                        }
                    }
                }
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::enum_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Color {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Color::Green => "Green",
                        Color::Red => "Red",
                        Color::Blue => "Blue",
                        Color::White => "White",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Color {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Color {
            #[inline]
            fn eq(&self, other: &Color) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Color {
            #[inline]
            fn default() -> Color {
                Self::Green
            }
        }
        #[fory(debug)]
        struct Item1 {
            f1: Color,
            f2: Color,
            f3: Option<Color>,
            f4: Option<Color>,
            f5: Option<Color>,
            f6: Option<Color>,
            f7: Color,
            f8: Option<Color>,
            f9: Option<Color>,
            last: i8,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item1 {
            fn fory_default() -> Self {
                Self {
                    last: <i8 as fory_core::ForyDefault>::fory_default(),
                    f1: <Color as fory_core::ForyDefault>::fory_default(),
                    f2: <Color as fory_core::ForyDefault>::fory_default(),
                    f3: <Option<Color> as fory_core::ForyDefault>::fory_default(),
                    f4: <Option<Color> as fory_core::ForyDefault>::fory_default(),
                    f5: <Option<Color> as fory_core::ForyDefault>::fory_default(),
                    f6: <Option<Color> as fory_core::ForyDefault>::fory_default(),
                    f7: <Color as fory_core::ForyDefault>::fory_default(),
                    f8: <Option<Color> as fory_core::ForyDefault>::fory_default(),
                    f9: <Option<Color> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                24u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f7",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f8",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f9",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &[
                    "last",
                    "f1",
                    "f2",
                    "f3",
                    "f4",
                    "f5",
                    "f6",
                    "f7",
                    "f8",
                    "f9",
                ];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i8 = 0 as i8;
                let mut _f1: Option<Color> = None;
                let mut _f2: Option<Color> = None;
                let mut _f3: Option<Option<Color>> = None;
                let mut _f4: Option<Option<Color>> = None;
                let mut _f5: Option<Option<Color>> = None;
                let mut _f6: Option<Option<Color>> = None;
                let mut _f7: Option<Color> = None;
                let mut _f8: Option<Option<Color>> = None;
                let mut _f9: Option<Option<Color>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f1 = Some(
                                    <Color as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f2",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f2 = Some(
                                    <Color as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f2",
                                    (&_f2) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            3i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f3",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f3 = Some(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f3",
                                    (&_f3) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            4i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f4",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f4 = Some(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f4",
                                    (&_f4) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            5i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f5",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f5 = Some(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f5",
                                    (&_f5) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            6i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f6",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f6 = Some(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f6",
                                    (&_f6) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            7i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f7",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f7 = Some(
                                    <Color as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f7",
                                    (&_f7) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            8i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f8",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f8 = Some(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f8",
                                    (&_f8) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            9i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    "f9",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f9 = Some(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    "f9",
                                    (&_f9) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item1",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item1",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Color as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Color as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Option<
                                Color,
                            > as fory_core::ForyDefault>::fory_default()),
                        f4: _f4
                            .unwrap_or_else(|| <Option<
                                Color,
                            > as fory_core::ForyDefault>::fory_default()),
                        f5: _f5
                            .unwrap_or_else(|| <Option<
                                Color,
                            > as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Option<
                                Color,
                            > as fory_core::ForyDefault>::fory_default()),
                        f7: _f7
                            .unwrap_or_else(|| <Color as fory_core::ForyDefault>::fory_default()),
                        f8: _f8
                            .unwrap_or_else(|| <Option<
                                Color,
                            > as fory_core::ForyDefault>::fory_default()),
                        f9: _f9
                            .unwrap_or_else(|| <Option<
                                Color,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 24u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = 1247860835i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,0;f3,0,0,1;f4,0,0,1;f5,0,0,1;f6,0,0,1;f7,0,0,0;f8,0,0,1;f9,0,0,1;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_i8(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color,
                > as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f4",
                    (&self.f4) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color,
                > as fory_core::Serializer>::fory_write(
                    &self.f4,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f4",
                    (&self.f4) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color,
                > as fory_core::Serializer>::fory_write(
                    &self.f5,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f6",
                    (&self.f6) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color,
                > as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f6",
                    (&self.f6) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f7",
                    (&self.f7) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color as fory_core::Serializer>::fory_write(
                    &self.f7,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f7",
                    (&self.f7) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f8",
                    (&self.f8) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color,
                > as fory_core::Serializer>::fory_write(
                    &self.f8,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f8",
                    (&self.f8) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item1",
                    "f9",
                    (&self.f9) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color,
                > as fory_core::Serializer>::fory_write(
                    &self.f9,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item1",
                    "f9",
                    (&self.f9) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = 1247860835i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,0;f3,0,0,1;f4,0,0,1;f5,0,0,1;f6,0,0,1;f7,0,0,0;f8,0,0,1;f9,0,0,1;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "last",
                    context,
                );
                let _last = context.reader.read_i8()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f1",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f1 = <Color as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f2",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f2 = <Color as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f2",
                    (&_f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f3",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f3 = <Option<
                    Color,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f3",
                    (&_f3) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f4",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f4 = <Option<
                    Color,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f4",
                    (&_f4) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f5",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f5 = <Option<
                    Color,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f5",
                    (&_f5) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f6",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f6 = <Option<
                    Color,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f6",
                    (&_f6) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f7",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f7 = <Color as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f7",
                    (&_f7) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f8",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f8 = <Option<
                    Color,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f8",
                    (&_f8) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item1",
                    "f9",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f9 = <Option<
                    Color,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item1",
                    "f9",
                    (&_f9) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                    f3: _f3,
                    f4: _f4,
                    f5: _f5,
                    f6: _f6,
                    f7: _f7,
                    f8: _f8,
                    f9: _f9,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "f1",
                    "f2",
                    "f3",
                    "f4",
                    "f5",
                    "f6",
                    "f7",
                    "f8",
                    "f9",
                    "last",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f2,
                    &self.f3,
                    &self.f4,
                    &self.f5,
                    &self.f6,
                    &self.f7,
                    &self.f8,
                    &self.f9,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Item1",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Item1 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Item1 {
            #[inline]
            fn eq(&self, other: &Item1) -> bool {
                self.last == other.last && self.f1 == other.f1 && self.f2 == other.f2
                    && self.f3 == other.f3 && self.f4 == other.f4 && self.f5 == other.f5
                    && self.f6 == other.f6 && self.f7 == other.f7 && self.f8 == other.f8
                    && self.f9 == other.f9
            }
        }
        #[fory(debug)]
        struct Item2 {
            f1: Color,
            f2: Option<Color>,
            f3: Color,
            f4: Option<Color>,
            f5: Color,
            f6: Option<Color>,
            last: i8,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item2 {
            fn fory_default() -> Self {
                Self {
                    last: <i8 as fory_core::ForyDefault>::fory_default(),
                    f1: <Color as fory_core::ForyDefault>::fory_default(),
                    f2: <Option<Color> as fory_core::ForyDefault>::fory_default(),
                    f3: <Color as fory_core::ForyDefault>::fory_default(),
                    f4: <Option<Color> as fory_core::ForyDefault>::fory_default(),
                    f5: <Color as fory_core::ForyDefault>::fory_default(),
                    f6: <Option<Color> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                25u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["last", "f1", "f2", "f3", "f4", "f5", "f6"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "last",
                            {
                                let mut ft = {
                                    let mut type_id = <i8 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <Color as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["last", "f1", "f2", "f3", "f4", "f5", "f6"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _last: i8 = 0 as i8;
                let mut _f1: Option<Color> = None;
                let mut _f2: Option<Option<Color>> = None;
                let mut _f3: Option<Color> = None;
                let mut _f4: Option<Option<Color>> = None;
                let mut _f5: Option<Color> = None;
                let mut _f6: Option<Option<Color>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "last",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _last = <i8 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _last = <i8 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "last",
                                    (&_last) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f1 = Some(
                                    <Color as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            2i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "f2",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f2 = Some(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "f2",
                                    (&_f2) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            3i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "f3",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f3 = Some(
                                    <Color as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "f3",
                                    (&_f3) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            4i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "f4",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f4 = Some(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "f4",
                                    (&_f4) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            5i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "f5",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Color as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f5 = Some(
                                    <Color as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "f5",
                                    (&_f5) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            6i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    "f6",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                let read_type_info = fory_core::types::need_to_write_type_for_field(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_static_type_id(),
                                );
                                _f6 = Some(
                                    <Option<
                                        Color,
                                    > as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        read_type_info,
                                    )?,
                                );
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    "f6",
                                    (&_f6) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Item2",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Item2",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        last: _last,
                        f1: _f1
                            .unwrap_or_else(|| <Color as fory_core::ForyDefault>::fory_default()),
                        f2: _f2
                            .unwrap_or_else(|| <Option<
                                Color,
                            > as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Color as fory_core::ForyDefault>::fory_default()),
                        f4: _f4
                            .unwrap_or_else(|| <Option<
                                Color,
                            > as fory_core::ForyDefault>::fory_default()),
                        f5: _f5
                            .unwrap_or_else(|| <Color as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Option<
                                Color,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 25u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i8 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Color as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<Color> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = 1205627001i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,1;f3,0,0,0;f4,0,0,1;f5,0,0,0;f6,0,0,1;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_i8(self.last);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "last",
                    (&self.last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color as fory_core::Serializer>::fory_write(
                    &self.f1,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color,
                > as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "f2",
                    (&self.f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "f3",
                    (&self.f3) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "f4",
                    (&self.f4) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color,
                > as fory_core::Serializer>::fory_write(
                    &self.f4,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "f4",
                    (&self.f4) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Color as fory_core::Serializer>::fory_write(
                    &self.f5,
                    context,
                    fory_core::RefMode::None,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "f5",
                    (&self.f5) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "Item2",
                    "f6",
                    (&self.f6) as &dyn std::any::Any,
                    context,
                );
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    Color,
                > as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "Item2",
                    "f6",
                    (&self.f6) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = 1205627001i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,0,0,0;f2,0,0,1;f3,0,0,0;f4,0,0,1;f5,0,0,0;f6,0,0,1;last,2,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "last",
                    context,
                );
                let _last = context.reader.read_i8()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "last",
                    (&_last) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "f1",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f1 = <Color as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "f2",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f2 = <Option<
                    Color,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "f2",
                    (&_f2) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "f3",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f3 = <Color as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "f3",
                    (&_f3) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "f4",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f4 = <Option<
                    Color,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "f4",
                    (&_f4) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "f5",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Color as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Color as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f5 = <Color as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::None,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "f5",
                    (&_f5) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "Item2",
                    "f6",
                    context,
                );
                let read_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<Color> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<Color> as fory_core::Serializer>::fory_is_polymorphic()
                };
                let _f6 = <Option<
                    Color,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    read_type_info,
                )?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Item2",
                    "f6",
                    (&_f6) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    last: _last,
                    f1: _f1,
                    f2: _f2,
                    f3: _f3,
                    f4: _f4,
                    f5: _f5,
                    f6: _f6,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &["f1", "f2", "f3", "f4", "f5", "f6", "last"];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f2,
                    &self.f3,
                    &self.f4,
                    &self.f5,
                    &self.f6,
                    &&self.last,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Item2",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Item2 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Item2 {
            #[inline]
            fn eq(&self, other: &Item2) -> bool {
                self.last == other.last && self.f1 == other.f1 && self.f2 == other.f2
                    && self.f3 == other.f3 && self.f4 == other.f4 && self.f5 == other.f5
                    && self.f6 == other.f6
            }
        }
        let mut fory1 = Fory::default().compatible(true).xlang(true);
        fory1.register_by_name::<Color>("a").unwrap();
        fory1.register::<Item1>(101).unwrap();
        let mut fory2 = Fory::default().compatible(true).xlang(true);
        fory2.register_by_name::<Color>("a").unwrap();
        fory2.register::<Item2>(101).unwrap();
        let item1 = Item1 {
            f1: Color::Red,
            f2: Color::Blue,
            f3: Some(Color::White),
            f4: Some(Color::White),
            f5: None,
            f6: None,
            f7: Color::White,
            f8: Some(Color::White),
            f9: Some(Color::White),
            last: 42,
        };
        let expected_item2 = Item2 {
            f1: Color::Red,
            f2: Some(Color::Blue),
            f3: Color::White,
            f4: Some(Color::White),
            f5: Color::default(),
            f6: None,
            last: 42,
        };
        let bin = fory1.serialize(&item1).unwrap();
        let actual_item2: Item2 = fory2.deserialize(&bin).unwrap();
        match (&expected_item2, &actual_item2) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::boxed"]
    #[doc(hidden)]
    pub const boxed: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("compatible::test_struct::boxed"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 532usize,
            start_col: 4usize,
            end_line: 532usize,
            end_col: 9usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(boxed())),
    };
    #[allow(clippy::unnecessary_literal_unwrap)]
    fn boxed() {
        struct Item1 {
            f1: i32,
            f2: i32,
            f3: Option<i32>,
            f4: Option<i32>,
            f5: Option<i32>,
            f6: Option<i32>,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item1 {
            fn fory_default() -> Self {
                Self {
                    f1: <i32 as fory_core::ForyDefault>::fory_default(),
                    f2: <i32 as fory_core::ForyDefault>::fory_default(),
                    f3: <Option<i32> as fory_core::ForyDefault>::fory_default(),
                    f4: <Option<i32> as fory_core::ForyDefault>::fory_default(),
                    f5: <Option<i32> as fory_core::ForyDefault>::fory_default(),
                    f6: <Option<i32> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item1 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                26u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f1", "f2", "f3", "f4", "f5", "f6"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f1", "f2", "f3", "f4", "f5", "f6"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f1: i32 = 0 as i32;
                let mut _f2: i32 = 0 as i32;
                let mut _f3: Option<Option<i32>> = None;
                let mut _f4: Option<Option<i32>> = None;
                let mut _f5: Option<Option<i32>> = None;
                let mut _f6: Option<Option<i32>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = <i32 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f1 = <i32 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = <i32 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f2 = <i32 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            3i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f4 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f4 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            4i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f5 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            5i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f6 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f6 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        f1: _f1,
                        f2: _f2,
                        f3: _f3
                            .unwrap_or_else(|| <Option<
                                i32,
                            > as fory_core::ForyDefault>::fory_default()),
                        f4: _f4
                            .unwrap_or_else(|| <Option<
                                i32,
                            > as fory_core::ForyDefault>::fory_default()),
                        f5: _f5
                            .unwrap_or_else(|| <Option<
                                i32,
                            > as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Option<
                                i32,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item1 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 26u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i32 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i32 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i32> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i32> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i32> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i32> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -569988738i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,5,0,0;f2,5,0,0;f3,5,0,1;f4,5,0,1;f5,5,0,1;f6,5,0,1;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_varint32(self.f1);
                context.writer.write_varint32(self.f2);
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i32> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i32> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i32,
                > as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i32> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i32> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i32,
                > as fory_core::Serializer>::fory_write(
                    &self.f4,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i32> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i32> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i32,
                > as fory_core::Serializer>::fory_write(
                    &self.f5,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i32> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i32> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i32,
                > as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -569988738i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,5,0,0;f2,5,0,0;f3,5,0,1;f4,5,0,1;f5,5,0,1;f6,5,0,1;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f1 = context.reader.read_varint32()?;
                let _f2 = context.reader.read_varint32()?;
                let _f3 = <Option<
                    i32,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f4 = <Option<
                    i32,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f5 = <Option<
                    i32,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f6 = <Option<
                    i32,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                Ok(Self {
                    f1: _f1,
                    f2: _f2,
                    f3: _f3,
                    f4: _f4,
                    f5: _f5,
                    f6: _f6,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item1 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &["f1", "f2", "f3", "f4", "f5", "f6"];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f2,
                    &self.f3,
                    &self.f4,
                    &self.f5,
                    &&self.f6,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Item1",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Item1 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Item1 {
            #[inline]
            fn eq(&self, other: &Item1) -> bool {
                self.f1 == other.f1 && self.f2 == other.f2 && self.f3 == other.f3
                    && self.f4 == other.f4 && self.f5 == other.f5 && self.f6 == other.f6
            }
        }
        struct Item2 {
            f1: i32,
            f2: Option<i32>,
            f3: Option<i32>,
            f4: i32,
            f5: i32,
            f6: Option<i32>,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Item2 {
            fn fory_default() -> Self {
                Self {
                    f1: <i32 as fory_core::ForyDefault>::fory_default(),
                    f4: <i32 as fory_core::ForyDefault>::fory_default(),
                    f5: <i32 as fory_core::ForyDefault>::fory_default(),
                    f2: <Option<i32> as fory_core::ForyDefault>::fory_default(),
                    f3: <Option<i32> as fory_core::ForyDefault>::fory_default(),
                    f6: <Option<i32> as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Item2 {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                27u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f1", "f4", "f5", "f2", "f3", "f6"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f4",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f5",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f2",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f3",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f6",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = true;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f1", "f4", "f5", "f2", "f3", "f6"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f1: i32 = 0 as i32;
                let mut _f4: i32 = 0 as i32;
                let mut _f5: i32 = 0 as i32;
                let mut _f2: Option<Option<i32>> = None;
                let mut _f3: Option<Option<i32>> = None;
                let mut _f6: Option<Option<i32>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = <i32 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f1 = <i32 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            1i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f4 = <i32 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f4 = <i32 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            2i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f5 = <i32 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f5 = <i32 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                            }
                            3i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f2 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f2 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            4i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f3 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f3 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            5i16 => {
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f6 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _f6 = Some(
                                        <Option<
                                            i32,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    field_type,
                                    read_ref_flag,
                                )?;
                            }
                        }
                    }
                    Ok(Self {
                        f1: _f1,
                        f4: _f4,
                        f5: _f5,
                        f2: _f2
                            .unwrap_or_else(|| <Option<
                                i32,
                            > as fory_core::ForyDefault>::fory_default()),
                        f3: _f3
                            .unwrap_or_else(|| <Option<
                                i32,
                            > as fory_core::ForyDefault>::fory_default()),
                        f6: _f6
                            .unwrap_or_else(|| <Option<
                                i32,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for Item2 {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 27u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i32 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i32 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <i32 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i32> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i32> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Option<i32> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -1699522985i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,5,0,0;f2,5,0,1;f3,5,0,1;f4,5,0,0;f5,5,0,0;f6,5,0,1;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                context.writer.write_varint32(self.f1);
                context.writer.write_varint32(self.f4);
                context.writer.write_varint32(self.f5);
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i32> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i32> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i32,
                > as fory_core::Serializer>::fory_write(
                    &self.f2,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i32> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i32> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i32,
                > as fory_core::Serializer>::fory_write(
                    &self.f3,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                let write_type_info = if context.is_compatible() {
                    fory_core::types::need_to_write_type_for_field(
                        <Option<i32> as fory_core::Serializer>::fory_static_type_id(),
                    )
                } else {
                    <Option<i32> as fory_core::Serializer>::fory_is_polymorphic()
                };
                <Option<
                    i32,
                > as fory_core::Serializer>::fory_write(
                    &self.f6,
                    context,
                    fory_core::RefMode::NullOnly,
                    write_type_info,
                    false,
                )?;
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -1699522985i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,5,0,0;f2,5,0,1;f3,5,0,1;f4,5,0,0;f5,5,0,0;f6,5,0,1;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                let _f1 = context.reader.read_varint32()?;
                let _f4 = context.reader.read_varint32()?;
                let _f5 = context.reader.read_varint32()?;
                let _f2 = <Option<
                    i32,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f3 = <Option<
                    i32,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                let _f6 = <Option<
                    i32,
                > as fory_core::Serializer>::fory_read(
                    context,
                    fory_core::RefMode::NullOnly,
                    false,
                )?;
                Ok(Self {
                    f1: _f1,
                    f4: _f4,
                    f5: _f5,
                    f2: _f2,
                    f3: _f3,
                    f6: _f6,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &["f1", "f2", "f3", "f4", "f5", "f6"];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.f1,
                    &self.f2,
                    &self.f3,
                    &self.f4,
                    &self.f5,
                    &&self.f6,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Item2",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Item2 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Item2 {
            #[inline]
            fn eq(&self, other: &Item2) -> bool {
                self.f1 == other.f1 && self.f4 == other.f4 && self.f5 == other.f5
                    && self.f2 == other.f2 && self.f3 == other.f3 && self.f6 == other.f6
            }
        }
        let mut fory1 = Fory::default().compatible(true).xlang(true);
        fory1.register::<Item1>(101).unwrap();
        let mut fory2 = Fory::default().compatible(true).xlang(true);
        fory2.register::<Item2>(101).unwrap();
        let f1 = 1;
        let f2 = 2;
        let f3 = Some(3);
        let f4 = Some(4);
        let f5: Option<i32> = None;
        let f6: Option<i32> = None;
        let item1 = Item1 { f1, f2, f3, f4, f5, f6 };
        let bytes = fory1.serialize(&item1).unwrap();
        let item2: Item2 = fory2.deserialize(&bytes).unwrap();
        match (&item2.f1, &f1) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f2.unwrap(), &f2) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f3, &f3) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f4, &f4.unwrap()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f5, &i32::default()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&item2.f6, &f6) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        let bytes = fory1.serialize(&f1).unwrap();
        let item2_f1: i32 = fory2.deserialize(&bytes).unwrap();
        match (&item2.f1, &item2_f1) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        let bytes = fory1.serialize(&f2).unwrap();
        let item2_f2: Option<i32> = fory2.deserialize(&bytes).unwrap();
        match (&item2.f2, &item2_f2) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        let bytes = fory1.serialize(&f3).unwrap();
        let item2_f3: Option<i32> = fory2.deserialize(&bytes).unwrap();
        match (&item2.f3, &item2_f3) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        let bytes = fory1.serialize(&f4).unwrap();
        let item2_f4: i32 = fory2.deserialize(&bytes).unwrap();
        match (&item2.f4, &item2_f4) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        let bytes = fory1.serialize(&f5).unwrap();
        let item2_f5: i32 = fory2.deserialize(&bytes).unwrap();
        match (&item2.f5, &item2_f5) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        let bytes = fory1.serialize(&f6).unwrap();
        let item2_f6: Option<i32> = fory2.deserialize(&bytes).unwrap();
        match (&item2.f6, &item2_f6) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
    }
    extern crate test;
    #[rustc_test_marker = "compatible::test_struct::test_struct_with_generic"]
    #[doc(hidden)]
    pub const test_struct_with_generic: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName(
                "compatible::test_struct::test_struct_with_generic",
            ),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "tests/tests/compatible/test_struct.rs",
            start_line: 608usize,
            start_col: 4usize,
            end_line: 608usize,
            end_col: 28usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(
            #[coverage(off)]
            || test::assert_test_result(test_struct_with_generic()),
        ),
    };
    fn test_struct_with_generic() {
        struct Wrapper<T> {
            value: String,
            _marker: PhantomData<T>,
            data: T,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Wrapper<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Wrapper",
                    "value",
                    &self.value,
                    "_marker",
                    &self._marker,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl<T> ::core::marker::StructuralPartialEq for Wrapper<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Wrapper<T> {
            #[inline]
            fn eq(&self, other: &Wrapper<T>) -> bool {
                self.value == other.value && self._marker == other._marker
                    && self.data == other.data
            }
        }
        #[fory(debug)]
        struct MyStruct {
            my_vec: Vec<Wrapper<Another>>,
            my_vec1: Vec<Wrapper<i32>>,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for MyStruct {
            fn fory_default() -> Self {
                Self {
                    my_vec: <Vec<
                        Wrapper<Another>,
                    > as fory_core::ForyDefault>::fory_default(),
                    my_vec1: <Vec<
                        Wrapper<i32>,
                    > as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for MyStruct {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                28u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["my_vec", "my_vec1"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "my_vec",
                            {
                                let mut ft = {
                                    let mut type_id = <Vec<
                                        Wrapper<Another>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <Wrapper<
                                                    Another,
                                                > as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        {
                                                            let mut type_id = <Another as fory_core::serializer::Serializer>::fory_get_type_id(
                                                                type_resolver,
                                                            )?;
                                                            if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                                || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                            {
                                                                type_id = fory_core::types::TypeId::UNION as u32;
                                                            }
                                                            let mut generics = ::alloc::vec::Vec::new()
                                                                as Vec<fory_core::meta::FieldType>;
                                                            if (type_id == fory_core::types::TypeId::LIST as u32
                                                                || type_id == fory_core::types::TypeId::SET as u32)
                                                                && generics.is_empty()
                                                            {
                                                                generics
                                                                    .push(
                                                                        fory_core::meta::FieldType::new(
                                                                            fory_core::types::TypeId::UNKNOWN as u32,
                                                                            true,
                                                                            ::alloc::vec::Vec::new(),
                                                                        ),
                                                                    );
                                                            }
                                                            let is_custom = !fory_core::types::is_internal_type(
                                                                type_id,
                                                            );
                                                            if is_custom {
                                                                if type_resolver.is_xlang() && generics.len() > 0 {
                                                                    return Err(
                                                                        fory_core::error::Error::unsupported(
                                                                            "serialization of generic structs and enums is not supported in xlang mode",
                                                                        ),
                                                                    );
                                                                } else {
                                                                    generics = ::alloc::vec::Vec::new();
                                                                }
                                                            }
                                                            fory_core::meta::FieldType::new(type_id, true, generics)
                                                        },
                                                    ]),
                                                ) as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "my_vec1",
                            {
                                let mut ft = {
                                    let mut type_id = <Vec<
                                        Wrapper<i32>,
                                    > as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            {
                                                let mut type_id = <Wrapper<
                                                    i32,
                                                > as fory_core::serializer::Serializer>::fory_get_type_id(
                                                    type_resolver,
                                                )?;
                                                if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                    || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                {
                                                    type_id = fory_core::types::TypeId::UNION as u32;
                                                }
                                                let mut generics = <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        {
                                                            let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                                                type_resolver,
                                                            )?;
                                                            if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                                                || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                                            {
                                                                type_id = fory_core::types::TypeId::UNION as u32;
                                                            }
                                                            let mut generics = ::alloc::vec::Vec::new()
                                                                as Vec<fory_core::meta::FieldType>;
                                                            if (type_id == fory_core::types::TypeId::LIST as u32
                                                                || type_id == fory_core::types::TypeId::SET as u32)
                                                                && generics.is_empty()
                                                            {
                                                                generics
                                                                    .push(
                                                                        fory_core::meta::FieldType::new(
                                                                            fory_core::types::TypeId::UNKNOWN as u32,
                                                                            true,
                                                                            ::alloc::vec::Vec::new(),
                                                                        ),
                                                                    );
                                                            }
                                                            let is_custom = !fory_core::types::is_internal_type(
                                                                type_id,
                                                            );
                                                            if is_custom {
                                                                if type_resolver.is_xlang() && generics.len() > 0 {
                                                                    return Err(
                                                                        fory_core::error::Error::unsupported(
                                                                            "serialization of generic structs and enums is not supported in xlang mode",
                                                                        ),
                                                                    );
                                                                } else {
                                                                    generics = ::alloc::vec::Vec::new();
                                                                }
                                                            }
                                                            fory_core::meta::FieldType::new(type_id, false, generics)
                                                        },
                                                    ]),
                                                ) as Vec<fory_core::meta::FieldType>;
                                                if (type_id == fory_core::types::TypeId::LIST as u32
                                                    || type_id == fory_core::types::TypeId::SET as u32)
                                                    && generics.is_empty()
                                                {
                                                    generics
                                                        .push(
                                                            fory_core::meta::FieldType::new(
                                                                fory_core::types::TypeId::UNKNOWN as u32,
                                                                true,
                                                                ::alloc::vec::Vec::new(),
                                                            ),
                                                        );
                                                }
                                                let is_custom = !fory_core::types::is_internal_type(
                                                    type_id,
                                                );
                                                if is_custom {
                                                    if type_resolver.is_xlang() && generics.len() > 0 {
                                                        return Err(
                                                            fory_core::error::Error::unsupported(
                                                                "serialization of generic structs and enums is not supported in xlang mode",
                                                            ),
                                                        );
                                                    } else {
                                                        generics = ::alloc::vec::Vec::new();
                                                    }
                                                }
                                                fory_core::meta::FieldType::new(type_id, true, generics)
                                            },
                                        ]),
                                    ) as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, true, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["my_vec", "my_vec1"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _my_vec: Option<Vec<Wrapper<Another>>> = None;
                let mut _my_vec1: Option<Vec<Wrapper<i32>>> = None;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "MyStruct",
                                    "my_vec",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _my_vec = Some(
                                        <Vec<
                                            Wrapper<Another>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _my_vec = Some(
                                        <Vec<
                                            Wrapper<Another>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "MyStruct",
                                    "my_vec",
                                    (&_my_vec) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            1i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "MyStruct",
                                    "my_vec1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _my_vec1 = Some(
                                        <Vec<
                                            Wrapper<i32>,
                                        > as fory_core::Serializer>::fory_read(
                                            context,
                                            ref_mode,
                                            false,
                                        )?,
                                    );
                                } else {
                                    _my_vec1 = Some(
                                        <Vec<
                                            Wrapper<i32>,
                                        > as fory_core::Serializer>::fory_read_data(context)?,
                                    );
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "MyStruct",
                                    "my_vec1",
                                    (&_my_vec1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "MyStruct",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "MyStruct",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self {
                        my_vec: _my_vec
                            .unwrap_or_else(|| <Vec<
                                Wrapper<Another>,
                            > as fory_core::ForyDefault>::fory_default()),
                        my_vec1: _my_vec1
                            .unwrap_or_else(|| <Vec<
                                Wrapper<i32>,
                            > as fory_core::ForyDefault>::fory_default()),
                    })
                }
            }
        }
        impl fory_core::Serializer for MyStruct {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 28u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <Vec<Wrapper<Another>> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
                    + <Vec<Wrapper<i32>> as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = -754422569i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "my_vec,20,0,0;my_vec1,20,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "MyStruct",
                    "my_vec",
                    (&self.my_vec) as &dyn std::any::Any,
                    context,
                );
                <Vec<
                    Wrapper<Another>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.my_vec,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "MyStruct",
                    "my_vec",
                    (&self.my_vec) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_write_field(
                    "MyStruct",
                    "my_vec1",
                    (&self.my_vec1) as &dyn std::any::Any,
                    context,
                );
                <Vec<
                    Wrapper<i32>,
                > as fory_core::Serializer>::fory_write_data_generic(
                    &self.my_vec1,
                    context,
                    true,
                )?;
                fory_core::serializer::struct_::struct_after_write_field(
                    "MyStruct",
                    "my_vec1",
                    (&self.my_vec1) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = -754422569i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "my_vec,20,0,0;my_vec1,20,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "MyStruct",
                    "my_vec",
                    context,
                );
                let _my_vec = <Vec<
                    Wrapper<Another>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "MyStruct",
                    "my_vec",
                    (&_my_vec) as &dyn std::any::Any,
                    context,
                );
                fory_core::serializer::struct_::struct_before_read_field(
                    "MyStruct",
                    "my_vec1",
                    context,
                );
                let _my_vec1 = <Vec<
                    Wrapper<i32>,
                > as fory_core::Serializer>::fory_read_data(context)?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "MyStruct",
                    "my_vec1",
                    (&_my_vec1) as &dyn std::any::Any,
                    context,
                );
                Ok(Self {
                    my_vec: _my_vec,
                    my_vec1: _my_vec1,
                })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MyStruct {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "MyStruct",
                    "my_vec",
                    &self.my_vec,
                    "my_vec1",
                    &&self.my_vec1,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MyStruct {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MyStruct {
            #[inline]
            fn eq(&self, other: &MyStruct) -> bool {
                self.my_vec == other.my_vec && self.my_vec1 == other.my_vec1
            }
        }
        #[fory(debug)]
        struct Another {
            f1: i32,
        }
        use fory_core::ForyDefault as _;
        impl fory_core::ForyDefault for Another {
            fn fory_default() -> Self {
                Self {
                    f1: <i32 as fory_core::ForyDefault>::fory_default(),
                }
            }
        }
        impl fory_core::StructSerializer for Another {
            #[inline(always)]
            fn fory_type_index() -> u32 {
                29u32
            }
            #[inline(always)]
            fn fory_actual_type_id(
                type_id: u32,
                register_by_name: bool,
                compatible: bool,
                xlang: bool,
            ) -> u32 {
                fory_core::serializer::struct_::actual_type_id(
                    type_id,
                    register_by_name,
                    compatible,
                )
            }
            fn fory_get_sorted_field_names() -> &'static [&'static str] {
                &["f1"]
            }
            fn fory_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<Vec<fory_core::meta::FieldInfo>, fory_core::error::Error> {
                let mut field_infos: Vec<fory_core::meta::FieldInfo> = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        fory_core::meta::FieldInfo::new_with_id(
                            -1i16,
                            "f1",
                            {
                                let mut ft = {
                                    let mut type_id = <i32 as fory_core::serializer::Serializer>::fory_get_type_id(
                                        type_resolver,
                                    )?;
                                    if type_id == fory_core::types::TypeId::TYPED_UNION as u32
                                        || type_id == fory_core::types::TypeId::NAMED_UNION as u32
                                    {
                                        type_id = fory_core::types::TypeId::UNION as u32;
                                    }
                                    let mut generics = ::alloc::vec::Vec::new()
                                        as Vec<fory_core::meta::FieldType>;
                                    if (type_id == fory_core::types::TypeId::LIST as u32
                                        || type_id == fory_core::types::TypeId::SET as u32)
                                        && generics.is_empty()
                                    {
                                        generics
                                            .push(
                                                fory_core::meta::FieldType::new(
                                                    fory_core::types::TypeId::UNKNOWN as u32,
                                                    true,
                                                    ::alloc::vec::Vec::new(),
                                                ),
                                            );
                                    }
                                    let is_custom = !fory_core::types::is_internal_type(
                                        type_id,
                                    );
                                    if is_custom {
                                        if type_resolver.is_xlang() && generics.len() > 0 {
                                            return Err(
                                                fory_core::error::Error::unsupported(
                                                    "serialization of generic structs and enums is not supported in xlang mode",
                                                ),
                                            );
                                        } else {
                                            generics = ::alloc::vec::Vec::new();
                                        }
                                    }
                                    fory_core::meta::FieldType::new(type_id, false, generics)
                                };
                                ft.nullable = false;
                                ft.ref_tracking = false;
                                ft
                            },
                        ),
                    ]),
                );
                let sorted_field_names = &["f1"];
                fory_core::meta::sort_fields(&mut field_infos, sorted_field_names)?;
                Ok(field_infos)
            }
            fn fory_variants_fields_info(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<
                Vec<(String, std::any::TypeId, Vec<fory_core::meta::FieldInfo>)>,
                fory_core::error::Error,
            > {
                Ok(Vec::new())
            }
            #[inline]
            fn fory_read_compatible(
                context: &mut fory_core::resolver::context::ReadContext,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let fields = type_info.get_type_meta().get_field_infos().clone();
                let mut _f1: i32 = 0 as i32;
                let meta = context
                    .get_type_info(&std::any::TypeId::of::<Self>())?
                    .get_type_meta();
                let local_type_hash = meta.get_hash();
                let remote_type_hash = type_info.get_type_meta().get_hash();
                if remote_type_hash == local_type_hash {
                    <Self as fory_core::Serializer>::fory_read_data(context)
                } else {
                    for _field in fields.iter() {
                        match _field.field_id {
                            0i16 => {
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Another",
                                    "f1",
                                    context,
                                );
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    _field.field_type.type_id,
                                    _field.field_type.nullable,
                                );
                                let ref_mode = if _field.field_type.ref_tracking {
                                    fory_core::RefMode::Tracking
                                } else if read_ref_flag {
                                    fory_core::RefMode::NullOnly
                                } else {
                                    fory_core::RefMode::None
                                };
                                if read_ref_flag || _field.field_type.ref_tracking {
                                    _f1 = <i32 as fory_core::Serializer>::fory_read(
                                        context,
                                        ref_mode,
                                        false,
                                    )?;
                                } else {
                                    _f1 = <i32 as fory_core::Serializer>::fory_read_data(
                                        context,
                                    )?;
                                }
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Another",
                                    "f1",
                                    (&_f1) as &dyn std::any::Any,
                                    context,
                                );
                            }
                            _ => {
                                let field_type = &_field.field_type;
                                let read_ref_flag = fory_core::serializer::util::field_need_write_ref_into(
                                    field_type.type_id,
                                    field_type.nullable,
                                );
                                let field_name = _field.field_name.as_str();
                                fory_core::serializer::struct_::struct_before_read_field(
                                    "Another",
                                    field_name,
                                    context,
                                );
                                fory_core::serializer::skip::skip_field_value(
                                    context,
                                    &field_type,
                                    read_ref_flag,
                                )?;
                                let placeholder: &dyn std::any::Any = &();
                                fory_core::serializer::struct_::struct_after_read_field(
                                    "Another",
                                    field_name,
                                    placeholder,
                                    context,
                                );
                            }
                        }
                    }
                    Ok(Self { f1: _f1 })
                }
            }
        }
        impl fory_core::Serializer for Another {
            #[inline(always)]
            fn fory_get_type_id(
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                type_resolver
                    .get_type_id(&std::any::TypeId::of::<Self>(), 29u32)
                    .map_err(fory_core::error::Error::enhance_type_error::<Self>)
            }
            #[inline(always)]
            fn fory_type_id_dyn(
                &self,
                type_resolver: &fory_core::resolver::type_resolver::TypeResolver,
            ) -> Result<u32, fory_core::error::Error> {
                Self::fory_get_type_id(type_resolver)
            }
            #[inline(always)]
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
            #[inline(always)]
            fn fory_static_type_id() -> fory_core::TypeId
            where
                Self: Sized,
            {
                fory_core::TypeId::STRUCT
            }
            #[inline(always)]
            fn fory_reserved_space() -> usize {
                <i32 as fory_core::Serializer>::fory_reserved_space()
                    + fory_core::types::SIZE_OF_REF_AND_TYPE
            }
            #[inline(always)]
            fn fory_write(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
                ref_mode: fory_core::RefMode,
                write_type_info: bool,
                _: bool,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write::<
                    Self,
                >(self, context, ref_mode, write_type_info)
            }
            #[inline]
            fn fory_write_data(
                &self,
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let version_hash: i32 = {
                        const VERSION_HASH: i32 = 563996978i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,5,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    context.writer.write_i32(version_hash);
                }
                fory_core::serializer::struct_::struct_before_write_field(
                    "Another",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                context.writer.write_varint32(self.f1);
                fory_core::serializer::struct_::struct_after_write_field(
                    "Another",
                    "f1",
                    (&self.f1) as &dyn std::any::Any,
                    context,
                );
                Ok(())
            }
            #[inline(always)]
            fn fory_write_type_info(
                context: &mut fory_core::resolver::context::WriteContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::write_type_info::<Self>(context)
            }
            #[inline(always)]
            fn fory_read(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                read_type_info: bool,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if ref_flag == (fory_core::RefFlag::RefValue as i8)
                        && ref_mode == fory_core::RefMode::Tracking
                    {
                        context.ref_reader.reserve_ref_id();
                    }
                    if context.is_compatible() {
                        let type_info = if read_type_info {
                            context.read_any_typeinfo()?
                        } else {
                            let rs_type_id = std::any::TypeId::of::<Self>();
                            context.get_type_info(&rs_type_id)?
                        };
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        if read_type_info {
                            <Self as fory_core::Serializer>::fory_read_type_info(
                                context,
                            )?;
                        }
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline(always)]
            fn fory_read_with_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
                ref_mode: fory_core::RefMode,
                type_info: std::rc::Rc<fory_core::TypeInfo>,
            ) -> Result<Self, fory_core::error::Error> {
                let ref_flag = if ref_mode != fory_core::RefMode::None {
                    context.reader.read_i8()?
                } else {
                    fory_core::RefFlag::NotNullValue as i8
                };
                if ref_flag == (fory_core::RefFlag::NotNullValue as i8)
                    || ref_flag == (fory_core::RefFlag::RefValue as i8)
                {
                    if context.is_compatible() {
                        <Self as fory_core::StructSerializer>::fory_read_compatible(
                            context,
                            type_info,
                        )
                    } else {
                        <Self as fory_core::Serializer>::fory_read_data(context)
                    }
                } else if ref_flag == (fory_core::RefFlag::Null as i8) {
                    Ok(<Self as fory_core::ForyDefault>::fory_default())
                } else {
                    Err(
                        fory_core::error::Error::invalid_ref(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Unknown ref flag, value:{0}", ref_flag),
                                )
                            }),
                        ),
                    )
                }
            }
            #[inline]
            fn fory_read_data(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<Self, fory_core::error::Error> {
                if context.is_check_struct_version() {
                    let read_version = context.reader.read_i32()?;
                    let type_name = std::any::type_name::<Self>();
                    let local_version: i32 = {
                        const VERSION_HASH: i32 = 563996978i32;
                        if fory_core::util::ENABLE_FORY_DEBUG_OUTPUT {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "[rust][fory-debug] struct {0} version fingerprint=\"{1}\" hash={2}\n",
                                        std::any::type_name::<Self>(),
                                        "f1,5,0,0;",
                                        VERSION_HASH,
                                    ),
                                );
                            };
                        }
                        VERSION_HASH
                    };
                    fory_core::meta::TypeMeta::check_struct_version(
                        read_version,
                        local_version,
                        type_name,
                    )?;
                }
                fory_core::serializer::struct_::struct_before_read_field(
                    "Another",
                    "f1",
                    context,
                );
                let _f1 = context.reader.read_varint32()?;
                fory_core::serializer::struct_::struct_after_read_field(
                    "Another",
                    "f1",
                    (&_f1) as &dyn std::any::Any,
                    context,
                );
                Ok(Self { f1: _f1 })
            }
            #[inline(always)]
            fn fory_read_type_info(
                context: &mut fory_core::resolver::context::ReadContext,
            ) -> Result<(), fory_core::error::Error> {
                fory_core::serializer::struct_::read_type_info::<Self>(context)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Another {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Another",
                    "f1",
                    &&self.f1,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Another {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Another {
            #[inline]
            fn eq(&self, other: &Another) -> bool {
                self.f1 == other.f1
            }
        }
        impl<T: 'static + Serializer + ForyDefault> Serializer for Wrapper<T> {
            fn fory_write_data(&self, context: &mut WriteContext) -> Result<(), Error> {
                context.writer.write_var_uint32(self.value.len() as u32);
                context.writer.write_utf8_string(&self.value);
                self.data.fory_write_data(context)?;
                Ok(())
            }
            fn fory_read_data(context: &mut ReadContext) -> Result<Self, Error> {
                let len = context.reader.read_varuint32()? as usize;
                let value = context.reader.read_utf8_string(len)?;
                let data = T::fory_read_data(context)?;
                Ok(Self {
                    value,
                    _marker: PhantomData,
                    data,
                })
            }
            fn fory_type_id_dyn(
                &self,
                type_resolver: &TypeResolver,
            ) -> Result<u32, Error> {
                Self::fory_get_type_id(type_resolver)
            }
            fn as_any(&self) -> &dyn std::any::Any {
                self
            }
        }
        impl<T: ForyDefault> ForyDefault for Wrapper<T> {
            fn fory_default() -> Self {
                Self {
                    value: "".into(),
                    _marker: PhantomData,
                    data: T::fory_default(),
                }
            }
        }
        let mut fory1 = Fory::default().compatible(true);
        let mut fory2 = Fory::default();
        let mut fory3 = Fory::default().xlang(true);
        fn inner_test(fory: &mut Fory) -> Result<(), Error> {
            fory.register::<MyStruct>(1)?;
            fory.register::<Another>(2)?;
            fory.register_serializer::<Wrapper<Another>>(3)?;
            fory.register_serializer::<Wrapper<i32>>(4)?;
            let w1 = Wrapper::<Another> {
                value: "Value1".into(),
                _marker: PhantomData,
                data: Another { f1: 10 },
            };
            let w2 = Wrapper::<Another> {
                value: "Value2".into(),
                _marker: PhantomData,
                data: Another { f1: 11 },
            };
            let w3 = Wrapper::<i32> {
                value: "Value3".into(),
                _marker: PhantomData,
                data: 12,
            };
            let w4 = Wrapper::<i32> {
                value: "Value4".into(),
                _marker: PhantomData,
                data: 13,
            };
            let ms = MyStruct {
                my_vec: <[_]>::into_vec(::alloc::boxed::box_new([w1, w2])),
                my_vec1: <[_]>::into_vec(::alloc::boxed::box_new([w3, w4])),
            };
            let bytes = fory.serialize(&ms)?;
            let new_ms = fory.deserialize::<MyStruct>(&bytes)?;
            match (&ms, &new_ms) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            };
            Ok(())
        }
        for fory in [&mut fory1, &mut fory2] {
            if !inner_test(fory).is_ok() {
                ::core::panicking::panic("assertion failed: inner_test(fory).is_ok()")
            }
        }
        if !inner_test(&mut fory3).is_err() {
            ::core::panicking::panic("assertion failed: inner_test(&mut fory3).is_err()")
        }
    }
}
